# Chapter 11 - Forensics and Malware Analysis
![](forensics.png)

This is the first of two chapters that will cover information security detection and response.  Security operations (secops) consists of people, processes, and technologies that monitor systems that can detect security events and incidents.  Once detected and validated, efforts are made to respond to threats by analyzing what took place, containing malicious activity, and recovering systems and operations to a known good state.  This chapter will introduce the basics and principles of digital forensics including standard investigation techniques.  It will also explore the various types and analysis methodologies of malicious software.  Understanding how to conduct a forensic investigation and analyze malware are important functions within the incident response process.

**Objectives**
1. Understand digital forensics fundamentals and processes.
2. Conduct a forensic investigation with Autopsy.
3. Describe malware types and analysis techniques.
4. Perform static and dynamic analysis of malicious software.
## Forensics
Part of the security function at organizations is to investigate a variety of cases that cover security incidents and how computer systems have been used.  **Digital forensics** is the investigation of electronic systems, such as storage media, operating systems, and log sources, to determine if some activity can be determined with a reasonable certainty.  This sub-discipline of information security includes processes such as the collection, preservation, validation, analysis, and conclusions of evidence gathered from digital sources.  This section will identify the types of cases, the investigatory process, data acquisition processes, media types, and forensic tools including the popular Autopsy case management software. 

>[!information] Info - Guide to Computer Forensics and Investigations
>If this subject interests the reader, I highly recommend Bill Nelson, Amelia Phillips, and Christopher Steuart's Guide to Computer Forensics and Investigations textbook (ISBN: 9780357688595).
### Public Case Types
Forensic investigation case scenarios are wide ranging and their outcomes can depend on whether the case is *public* or *private* sectors.  Public cases consist of a criminal element where there are authorities attempting to prosecute a crime.  The *digital investigator* assists law enforcement investigations by gathering and analyzing digital evidence.  In addition, prosecuting or defense attorneys may hire digital investigators to validate law enforcement investigations and identify exculpatory (absolve) or inculpatory (incriminates) evidence.  

Public cases involve almost any type of technology that can be used as part of a crime.  Many crimes involve some type of digital technology such as, but not limited to, telecommunications over smart phones, digital cameras, as well as workstations and laptops.  Collecting the devices and media involved in these types of cases may only be done so within the bounds of the law.  The collection of evidence in public investigations is restricted in the United States by the 4th Amendment which outlines criteria for search and seizures.  Generally, evidence may only be collected where there is probably cause, a search warrant, or court order.  Only the material, persons, and place defined in warrants and court orders may be seized to be used in a forensic investigation. 

### Private Case Types
Organizations also perform digital forensic investigations which are known as private sector cases.  The goal of these cases is rarely criminal prosecution as organization typically want to limit risk.  This risk could include financial loss caused by reputational damage, theft, or other malicious activity.  Private cases may result in the organization escalating the matter to authorities or pressing charges in civil court where forensics investigators could be hired by attorneys on both sides.  Most cases do not rise to this level as court records are available to the public and most companies try to avoid the negative publicity.  

Many members or employees of an organization in the United States do not have an expectation of privacy while using the organization's networks and devices.  This means that forensic investigators have access to almost any data needed to conduct investigations.  This not only includes direct access to devices but also corresponding the server logs.  Typically, such invasion is allowed due to an organization's acceptable use policy which defines that all activity performed on organization devices and digital assets is monitored.

Private cases often involve employee theft of intellectual data, data breaches, and human resource issues.  Typically an investigator may only have to deal with a relatively small set of technologies and devices as organizations commonly homogenize their technologies for ease administration and cost effectiveness.  For example, a business may only have Windows 11 operating systems on workstations which exempts the investigator from having to know MacOS or Linux forensics techniques.
### Investigatory Process
Proper handling of investigations is paramount to ensure a thorough and well vetted conclusion for a case.  Forensic investigators should apply a methodical approach and adhere to a linear **investigation process** that promotes the integrity of evidence and analysis.  These efforts must start before a case event begins during the *preparation* phase which prepares the investigator with the knowledge, skillset, tooling, and workspace needed.  Forensic professionals should be well trained in common forensic techniques and methods by completing certifications and attending industry conferences.  These will expose the professional to the latest trends in technology and the tools available to assist with investigations.  

The investigator must also have a reasonable workspace that ensures digital evidence is well protected such as a dedicated office space and fireproof locking file cabinet.  This office or *forensics lab* should have access restricted to only those with a need to know and be equipped with the hardware and software needed to perform investigations.  Hardware includes workstations powerful enough to handle multiple input/output devices, drives, disc cloners, write blockers, and portable forensic devices.  A physical toolset that includes items like screwdrivers and various cabling that might be needed during an investigation must also be available prior to commencing an investigation.  Lastly, the software tools to collect and analyze evidence securely must be procured and installed to support the investigation.

After preparation, the next step in the investigatory process is the *acquisition phase* where evidence is collected.  During this time the investigator will collect physical devices and media, make forensic copies, and inventory the items collected.  It is crucial that the evidence collected is secured at all times to avoid the corruption or mishandling of data which could jeopardize a case's integrity.  Once evidence is collected and forensic copies are made, the next step is *validation* where original data sources are confirmed to exactly match with forensic copies made.  Validation is performed using a hashing algorithm where if even a one "bit" is altered in the evidence an entirely different hash digest will be calculated.

>[!info] Info - AccessData's FTK Imager
>A very popular professional data acquisition tool is AccessData's FTK Imager which allows you to make image copies of attached drives.  The following screenshot is a sample of the user interface exploring an image and starting an image copy process.
>![[../images/11/ftk_imager.png|FTK Imager Drive Copying|500]]

Forensic investigators work off of digital copies to avoid inadvertently corrupting or changing the original evidence.  These copies are used in the *investigation phase* of the process where a case is prepared, evidence is analyzed, and notes are taken that drive an investigation.  Every case is different, but usually the investigator has some context of what is to be reviewed.  For example, an employee harassment claim might include a collection of emails to be analyzed or an intellectual property theft case may require the analysis of a hardware drive.

After the investigation, where digital evidence is identified and tagged in case management software, the *reporting phase* aggregates the methods of the investigation, description of evidence collected, and conclusions made from analyzing the evidence.  This last step typically results in a formal written document which may be used as *testimony* in a court setting.
### Data Acquisition
A serious component of digital forensics is the collection of evidence or **data acquisition**.  While the investigator will obtain a device's storage media, investigations are usually not performed directly on the device if it can be avoided.  This is because any activity the investigator performs on the device could corrupt the original storage data and lose it's repudiation.  Even powering up a device will update timestamps on the operating system and file system which may overwrite potentially important data to the investigation.  Therefore, an investigator will produce one or more forensic copies from the original data source.

Prior to making a copy of a subject storage media, the investigator will prepare a target drive to copy data onto.  This drive must have capacity large enough to accommodate the copied data.  It must also be free of any other data, especially malware.  Typically the investigator would securely wipe the target drive using a tool such as *Derek's boot and nuke (DBAN)*.  This software overwrites every "bit" on the drive in one or more iterations.  Once a target drive is clean, it can be initialized, partitioned, and a file system such as Microsoft's NTFS mounted on it.  Alternatively, a drive could be securely wiped and then used to clone the subject storage media using device cloner hardware or software like *data dump (dd)* .  Once the drive is prepared, it is ready to be used to store forensic copies of evidence like ISO image files.

There are several collection methods to consider depending on the context of a case.  *Disk to image* collection takes a single file image copy of a subject disk.  *Disk to disk* collection makes a bit for bit copy of the subject drive onto the target drive sometimes referred to as cloning.  Many investigations may not require the compete drive and may instead rely on the collection of specific files, such as the PST database of a user's email box.  When collecting only specific files the collection methodology is referred to as a *logical* acquisition.  Finally, some storage media may be too large to collect as a disk image from, such as the case with *redundant array of independent disks (RAID)* systems.  Therefore, an investigator may choose the *sparse* collection method where only sections of a disk are acquired from a subject drive.

Investigators must determine whether to perform a *live* or a *static* acquisition depending on the circumstances of an acquisition.  *Static* collections are taken from storage media while the device is powered off.  An example of this type is removing a drive from a workstation and cloning it.  Investigators should use a *write blocker* hardware device or software feature to ensure data is not inadvertently written to the subject drive while performing a static acquisition.  The other type of acquisition is the *live* method which is performed while a subject device is powered on.  This method may have the affect of writing data to the subject drive  Investigators can limit or mitigate the negative effects of this by taking detailed notes and logs all of their activity.  The benefit to live acquisitions is that the investigator will have more information available to them including processes running in memory and opened applications.  Another benefit to a live acquisition is that it could be the only way to retrieve files stored on encrypted drives.  A password or key is required to decrypt drive contents which might not be shared with an investigator so performing a live acquisition on a device already powered on and decrypted could be the only way to ensure evidence is collected.

>[!info] Info - Write Blocker
>Write blockers are a vital tool used by forensic investigators to ensure data is not inadvertently written to a subject drive.
>![[../images/11/write_blocker.png|Write Blocker Connected to Hard Drive|400]]
>Credit: https://en.wikipedia.org/wiki/Forensic_disk_controller

Investigators may also have to consider performing acquisitions onsite or remotely.  In many cases the acquisition is conducted onsite, meaning the investigator is physically present relative to the storage media.  However, the investigator could perform an acquisition remotely which is a type of live acquisition where data is sent over a network to the investigator.  Remote acquisitions are very common in private sector cases as employee computers have preinstalled remote access tooling available to investigators.  This tooling enables administrators and security professionals to access a device ad hoc and copy any needed files or drives.

Acquisitions result in one or more files being created for the investigation.  While the collected data could be from logical acquisitions and include graphic files, documents, or databases, disk acquisitions produce image or disk files.  An entire drive can be collected into a single file making it highly portable.  The most common and versatile image or disk file format is the raw format.  Most acquisition and investigation software supports the creation or analysis of raw file types.  However, some commercial grade forensics software prepares forensic copies using proprietary formats and are less commonly supported by other digital forensics software.  While being less flexible, these proprietary systems include additional features not supported by the raw format, such as logging, compression, file splitting, and validations. 

The generalized process of the acquisition phase for an investigation can be summarized as follows:
1. Preparing the target drive;
2. Acquiring the subject media;
3. Connecting the subject media to a write blocker;
4. Making a forensic copy;
5. Validating the subject drive and forensic copies match;
6. Logging evidence *chain of custody*; and 
7. Securely storing the evidence to be used later during the investigation phase.

Once evidence is collected, the next phase of the case can commence where the forensic investigator analyzes the contents of the drive or files.
### Analysis Types
There are several types of digital forensic analysis types that investigators perform.  The objectives of each case will depend heavily on the context and circumstances surrounding why the investigation was requested.  Often investigators are requested to prove or disprove some activity on a device which offers some insights as to where and what to look for.  Many investigations are straight forward and evidence is relatively simple to observe.  For instance, in an email investigation, the forensics professional may identify the subject email on the system or from an email server.  However, the investigator must ensure the authenticity of the email with some level of confidence.  This could be accomplished by reviewing the email's header information and comparing it to the ESMTP IDs found within email server logs to ensure the email was not fabricated or altered.

Some investigations center around the analysis of storage media such as hard drives.  These investigations may search for deleted files proving target information was on the drive.  When a user deletes a file, such as through the operating system's file deletion feature, the file system simply updates the file table by marking that space on the drive as available for writing new data to.  The deletion action does not remove the data of that file from the disk and a forensic investigator could retrieve part or all of that file after it has been deleted.  Data can also be recovered from a file's *slack space* which is the space on the drive from the logical end of the file to the end of the sector.  Sectors are usually 512 bytes and support only one file at a time.  A file can consume several sectors, groups called *clusters*, but the last sector will likely not be fully used.  The slack space of a file could contain the remnants of previous files or may contain data purposefully hidden.  Drive partitions, where file systems are installed, are labeled with a partition name and assigned a drive letter in Microsoft Windows.  But a partition might not be initialized by the operating system and could otherwise be invisible to casual users.  An investigator may search a drive seeking to identify any hidden partitions to identify additional files of interest.

> [!warning] Warning - Anti-forensics
> I've have already mentioned a couple techniques where data could be purposefully hidden. Such efforts are known as *anti-forensics* techniques and investigators must be not only aware of them but also how to overcome them to ensure a comprehensive investigation. 

Another type of analysis focuses on the file system installed on subject drives.  There are many types and versions of file systems which vary depending on the type of operating system using them.  Windows devices now use the *new technology file system (NTFS)* but used *file allocation table (FAT)* versions in the past.  Linux commonly uses the *extended file system version 4 (EXT4)* while Apple has the *Apple file system (APFS)*.  Both Linux and Apple systems also support older file systems and versions.  All file systems generally work the same way by organizing how files are stored and utilized on a disk.  The file system is like a map used by an operating system to manage files.  An investigator must understand how these systems work and where subject data could be stored.  For example, file systems keep track of areas on the disk that have bad sectors (or blocks) to avoid reads and writes that corrupt a file.  A subject may attempt to hide data in a cluster and then update the file system's bad sector table to include the sectors where they stashed data.

The types of files can also be the subject of interest in an investigation.  One technique investigators will use is by identifying file extension mismatches with the file header or magic bytes.  The magic byte of a file is the hex code at the beginning of a file used by applications to identify the file type before processing.  Identifying files by their magic bytes ensures the actual file type being analyzed.

Operating systems (OS) are the means which most users interact with a device.  The major OSs Windows, Linux, and MacOS track system and user activity in various ways.  For instance, Windows systems have a *registry* which is a configuration database the operating system and applications use to store and retrieve information.  The registry is rich with data that includes information such as the last time a program may have been run and by which user.  Such information could be highly valuable to an investigation.  For live acquisitions and investigations, the contents of a system's *random access memory (RAM)* can be collected and analyzed known as *memory forensics*.  Here the investigator dumps memory content from a powered on device to review the running programs or processes contents.

Cases may require the analysis of networks as well.  In these cases, log activity is collected from network devices such as routers and firewalls and analyzed.  Investigators will identify relevant activity performed in the network related to the case.  These investigations could include a packet capture which could be analyzed in using tools like Wireshark even going as far as extracting files that were transferred over a network.
### Forensic Software Tools
The primary activities in digital forensics is the acquisition and then analysis of evidence.  There are many software tools that support both these efforts.  Only well vetted software tools should be relied upon and used as part of an investigation.  The forensic investigator will need to ensure the tools they use produce valid and accurate results.  Therefore, investigators should use tools that are highly reputable and well supported.

In an earlier section we covered the acquisition phase of a case.  Two common software tools used are Linux's native *data dump (dd)* and AccessData's FTK Imager.  They support the creation of forensic copies and are widely used in the industry.  DD is a command line utility that can take bit for bit copies of storage systems into a raw format.

The organization of cases and review of data are supported by analysis software such as the opensource Autopsy or commercial OSForensics by PassMark.  Both Autopsy and OSForensics offer features such as case management where evidence can be logically separated from other cases while being assigned to specific investigators or teams.  Other features include modules designed to ingest data sources and automate the identification of evidence through scanning.  For instance, either tool can detect and recover files that have been deleted or identify hidden partitions on a subject disk.  These tools can also create timelines and generate reports that save time and increase quality of investigations.

>[!activity] Activity 11.1 - Forensic Investigation
>In this activity I will demonstrate the analysis of a subject forensic image using Autopsy on my Windows VM.  Autopsy is a free and opensource digital forensics investigation platform.  I'll create a case, load the source image, and run analysis ingestion modules that will identify areas of interest.  From there, I will manually enumerate and hunt for potential evidence using many of the features built into the application.
>
>Once the Windows VM is fully started, I open the Edge browser, navigate to https://www.autopsy.com/download/ and and download the Autopsy MSI.
>![[../images/11/forensic_activity_autopsy_download.png|Downloading Autopsy Installer|450]]
>After the MSI downloads, I double click the installer from my Downloads folder to initiate the installation process.  This required me to accept warning messages from Edge security and Windows Smart Screen.  Once running, I accept UAC prompts and use the default or recommended installation settings.  Eventually the Autopsy installation completes and a shortcut is added to my Desktop.  Double clicking the shortcut launches Autopsy to the following screen.
>![[../images/11/forensics_activity_autopsy_started.png|Autopsy Launched|650]]
>I select New Case and enter a case name of "USB Drop" then provide the path to my Desktop folder where the case files will be stored.
>![[../images/11/forensic_activity_case_info.png|Entering Case Information|650]]
>After pressing next, I supply a case number as well as my name under the Examiner field before hitting the Finish button.  This action creates the case files locally on my Desktop.
>![[../images/11/forensics_activity_case_info_2.png|Other Case Information|650]]
>The next step is adding the data source which I've already downloaded onto my Windows VM.  The file `forensics.E01` was acquired using Encase software and contains a file system from a USB drive.  This investigation requires me to examine the contents of the USB.  I'm first prompted to generate a host name, which I leave to the default, then I press Next.  I then leave the data source type as "Disk Image or VM File" and hit Next.  Afterwards, I choose the path of the `forensics.E01` file and press Next again.
>![[../images/11/forensics_activity_data_source.png|Choosing Data Source Path|500]]
>The Configure Ingest step lists all the ingestion modules available to run against the data source.  These preinstalled modules will analyze the image and identify various areas of interest.  All modules are selected by default so I hit the Next button and after a few moments the Finish button.
>![[../images/11/forensics_activity_modules.png|Ingestion Module Selection|650]]
>While the ingestion modules run in the background, I am presented with the Autopsy application's main work window.  The left most pane provides navigation that includes the data source drive as well as the results from the ingestion modules.  The right top pane lists folder contents selected from the navigation pane whereas the right bottom pane displays the content and additional information of selected files from the right top pane.  There is also a progress bar in the bottom right corner which shows the level of completion for the ingestion modules.
>![[../images/11/forensics_activity_autopsy.png|Autopsy Main Window|650]]
>I can navigate the data source drive by expanding the Data Sources tree and selecting folders of interest.
>![[../images/11/forensics_activity_drive_review.png|Review Drive Contents|400]]
>Autopsy comes with a keyword search and built-in regular expression patterns as part of the keyword list feature in the upper right corner of the application.  
>![[../images/11/forensics_activity_keyword_list.png|Keyword Lists Search Feature|400]]
>Selecting Phone Numbers and running a search results in the identification of every file that has a known phone number pattern in its files contents.  This advance searching allows an investigator to quickly identify files of potential interest.
>![[../images/11/forensics_activity_phone_search.png|Phone Number Search Results|600]]
>Autopsy ingest modules also identify file types and aggregates them as a quick reference in the navigation pane.  Here I can find specific file types such as zip files.
>![[../images/11/forensics_activity_file_types.png|File Type Aggregation|550]]
>One way a person might attempt to obfuscate files is to change the file extension so that the OS identifies the file as an incorrect type.  However, Autopsy detects file extension mismatches and tags them in the navigation pane.  The MIME type of this file is JPEG but its extension is a DAT file!
>![[../images/11/forensics_activity_mismatch.png|Mismatch File Type Detection|650]]
>Files, including previously deleted files, can be recovered from forensic images using Autopsy.  Under File View in the left navigation pane is a Deleted Files category.  Expanding this tree shows all the files that were previously deleted that are still recoverable.  Selecting a file and right-clicking it displays the context menu with the Extract Files option.
>![[../images/11/forensics_activity_deleted_files.png|Deleted Files Recovery|650]]
>Extracting the file, or file *carving*, will save a copy to my case folder on my Desktop where it can be further examined using other tools.
>![[../images/11/forensics_activity_carving.png|Carved File|350]]
>There are many more features in Autopsy that extend beyond the scope of this activity.  The tool is very powerful and enables forensic investigators to quickly parse through an image and find interesting files.
>
## Malicious Software
Software that performs unwanted and ill-natured behavior is called **malicious software** or malware for short.  They are written by malicious actors with the intent of inducing some harm on the device it is ran on.  This section of the chapter explores the types and behaviors of malware as well as some methods of detecting and analyzing what the malware does.  It is important for investigators to understand how a malware behaves that infected a system.  This information will lead them to the activities and impacts the malware caused after infecting a system.  Without having this understanding, the investigator or malware analyst won't know the extent of damage caused by the malware.

The threat landscape for malicious software has only increased and matured as a result of financial incentives, societal reliance on technology, and the lack of accountability to identify and punish malicious actors.  While the idea of a lone malicious actor still exists, the most threatening attackers band together in desperate groups supported by sophisticated marketplaces.  The *darknet*, accessible through The Onion Router (TOR) encrypted networks, provides threat actors with anonymity and digital communities that offer tradecraft, communications, and commerce all with mal intent.  Nowadays, independent attackers specialize in specific fields such as *initial access brokers* who compromise user accounts to sell to other attackers.  Those who purchase initial access may register as an affiliate with a darknet vendor such as a *ransomware as a service* "company."  Ransomware operators sell customer support services and employ or purchase ransomware malware from third party developers.  All these actors work independently but are part of a large distributed criminal organization that causes havoc to victims.
### Types of Malware
Malware has its history dating as far back as the mid 60's when computer scientists theorized that  software could be designed to self replicate.  The first widely publicized attempt at creating a self reproducing piece of software was developed in 1971 and known as the Creeper worm.  By the early to mid 80's, malicious software started to appear coinciding with the rise of the personal computer. [^1]  By the late 80's, the first anti-virus solution named McAfee hit the market with the aim to identify and mitigate known malicious software.  The volume of malware increased with the popularity of the internet in the mid 90's as more consumers began to rely on computer systems to conduct personal and commercial tasks.  As computers, network systems and antivirus solutions grew in complexity so did the types and volume of malicious software.  These days, the rate of new malware grows exponentially as society becomes more reliant on computer systems and the incentives increase for malicious software developers.

>[!tip] Tip - Potentially Unwanted Program
>Some antivirus solutions will also detect *potentially unwanted programs (PUP)* which is software that might not be useful but is not necessarily malicious.

As technology expands and there is more incentive to abuse digital systems, the volume of malware continues to increase.  During this rise of malicious software, patterns begin to emerge that promote the categorization of malware into types defined by their behavior.  A **worm** can self reproduce spreading to new systems in an autonomous manner.  They can be particularly devastating as their spread quickly becomes uncontrolled.  **Spyware** is another class of malicious software designed to monitor system activity it is installed on and report back to information like device location, files or images created, and applications used.  Typically, spyware attempts to keep a low profile as the authors don't want it to be detected so it can continue its collection of data.  One type of spyware is a *keylogger* which will log every keystroke received from a keyboard.  Within this captured data is sensitive data like banking details and secrets like passwords.

Some malware's impact is fairly benign and has a relatively low impact to a user's system.  For example, **adware** is a type of malware that serves or injects ads to a user in an attempt to collect revenue from an internet advertisement agency.  There are many other advertisement abuse schemes designed to bilk money from ad services like Google which may not affect a user's device.  Some malicious actors even advertise malware cloaked as legitimate software through advertisers in the hopes that a victim will click on the advertisement and download some malicious software.  The financial motives of malware authors includes other initiatives such as *carding* malware which is designed to steal credit card information.  One type of carding software is *Magecart* which affects ecommerce platforms and skims credit card information to be used or sold on the darknet.

Modern financially incentivized malware leverages the anonymity and value of crypto currencies like Bitcoin.  Although the concept behind **ransomware** predates the creation of crypto currencies, it has become a wildly popular malware type starting in the early 2010s.  Ransomware encrypts data with a key that only the attacker has and a demand for payment in anonymous crypto currency is made in exchange for the decryption key.  This extortion can be compounded if the attacker also exfiltrates the files before they encrypt  the data.  Thereafter, the attacker then also demands additional payment to not release the files onto the internet.  Organizations often face the ethical dilemma of whether to pay the ransom to attempt recovering their operations, having to trust the malicious actors technology and commitment, versus further incentivizing the propagation and use of ransomware on future victims.  Every payment made to ransomware operators is validation to the malicious actors to continue their business model.  Another type of malware gaining popularity due to the creation and valuations of cryptocurrencies are **cryptominers**.  This malware infects a device and runs software that mines for cryptocurrencies while using the victims resources such as energy bill or cloud accounts.  Given the primary cost of cryptominers is electricity, the attackers enjoy the proceeds of mining without having to pay for th electricity their victims are on the hook for with their utility companies.

>[!info] Info - As a File or Fileless
>Malware can be many types of files, really anything that runs code.  However, malware that runs only in memory called *fileless malware* also exists.  Such malware can be difficult to detect using traditional antivirus solutions since their is no malicious file that ever touches the file system.

An attacker may want to gain remote access to a victim's device and use it for a variety of malicious purposes such as to gain further access into a network or stage additional attacks from the victim's device.  Malware that provides attackers with remote access is called a **trojan** named after the Greek mythology wooden horse used to conquer the city of Troy.  The Msfvenom payloads used in the Security Testing chapter are examples of tojans also referred to as *remote access tojans (RAT)*, that gives the attacker full system control.  Some malicious actors work to compromise many devices, sometimes tens of thousands, into a robot army called a *botnet*.  These botnets are then used to perform *distributed denial of service (DDoS)* attacks against other victims where each bot performs continuous network requests against a single target overwhelming the victim and causing the system to crash or otherwise be unavailable to legitimate users.
### Malware Behavior
Most malware infections start with a victim downloading a malicious file or app from the internet in one form or another.  This includes files from phishing emails, browser extensions, mobile applications, or any other source a person may be tempted to download and run on their device.  Malware can even be downloaded from trusted sources that were compromised through *supply chain attacks*.  Wherever there is an opportunity to run code or an executable, there is a malicious actor designing malware to be used in that vector.

The simplest form of malware could be a file that runs a malicious command; however, this type of threat is usually easily detected by modern anti-malware systems.  As a result of these security controls, malware authors have expanded the complexity of how malware behaves often to avoid detection and analysis.  Most infections will start with some initial vector such as a file that has been compressed, encrypted, or prepared to avoid detection through firewalls or email systems.  When the victim opens this initial file, a *loader* or *dropper* is run that retrieves another malicious file.  This file could be heavily obfuscated, again to avoid detection and analysis, but when it is run it could download yet another file known as a *stager*.  Any number of stages could flow through this process until the final malicious payload is deployed on the system.

>[!tip] Tip - Anti-analysis
>Malicious actors go to great lengths to dissuade security professionals from analyzing their malware in an attempt to evade further detection or to hide true intensions.  Such efforts are called *anti-analysis* and can present a series of challenges for malware analysis professionals to dissect how the malicious software operates. 

Once the malware takes hold it could begin any number objectives it was designed to accomplish.  Some malware may attempt to hide itself throughout the operating system or even embed itself into the master boot record known as a *bootkit*.  The goal would be to establish some persistence in case the malware's process is terminated such as through a system reboot for example.  Some wormable malware may seek to pivot to other network devices or seek to infect removable storage devices like cellular phones or USB drives.  The final stage could even be self wiping or destruction where the malware deletes or removes all traces of its activities from logs, file artefacts created from proceeding stages, and even remove itself.
### Detecting Malware
The first efforts to detect and remove malware used static hash digests, such as MD5, comparing device files against a database of hashes for known malware.  If there was a hash match the file would be considered malicious and quarantined or removed from the system.  While this worked well, and still has its place in modern security controls, it can be easily bypassed with small modifications to the malicious file which will yield a different hash.  In addition, under the **static hash detection** technique, novel malware is undetected.

The countermeasure to malware authors slightly modifying existing malware to avoiding hash detection is to check specific characteristics of a malicious file.  These characteristics are organized into rules that are fed into a detection engine.  They look for things like strings and hexadecimal code values at specific offsets in a file known as the **fingerprinting detection** technique.  A very popular opensource solution for detecting malware this way uses Yara.  Malware analysist and security researchers studying malware behavior will write Yara rules and publish them for public consumption such as through community subscriptions to rulesets.

However, malicious actors can also subscribe to these rulesets and modify their malware to specifically evade detection.  It is possible to derive these rules even if one does not have access to the rule.  For example, if the Windows LSAS secret dumping utility Mimikatz was downloaded to a Windows device that had Defender enabled it would immediately be detected and removed.  Taking that Mimikatz binary and breaking it into several smaller files would reveal some file fragments being identified and removed and others not.  Then breaking those blocked fragments into even smaller files and repeating the steps over until the specific offending string or hexadecimal code is identified that Defender takes issue with will reveal what needs to be modified to bypass the antivirus solution.

Advanced antimalware solutions hook into each process memory space and inspects running application's activities.  This **anomalous behavior detection** technique used in antimalware solutions and sometimes called *endpoint detection and response (EDR)* monitors running programs behavior.  These monitored behaviors include file system activity, API calls, and network connections which are commonly associated with malicious activity.  This has the distinct advantage over static and fingerprinting techniques since it does not rely on specific data and instead is heuristically based.  However, it too can be bypassed using methods like those demonstrated in the Operating System Security anti-virus bypass activity.

>[!activity] Activity 11.2 - Malware Detection
>Yara is a malware detection tool supported by a large opensource and commercial community.  It is common for malware researchers to create Yara rules for novel malware that is shared and distributed through subscription feeds.  Using the Kali virtual machine, I will create a Yara rule to detect Mimikatz which comes preinstalled on the file system.
>
>After powering on Kali and opening a terminal, I install Yara using apt.
>```bash
>wget https://ftp.debian.org/debian/pool/main/y/yara/libyara9_4.2.3-4_amd64.deb
>wget https://ftp.debian.org/debian/pool/main/y/yara/yara_4.2.3-4_amd64.deb
>```
>Once download both DEB files, I install them using dpkg.
>```bash
>sudo dpkg -i libyara9_4.2.3-4_amd64.deb
>sudo dpkg -i yara_4.2.3-4_amd64.deb
>```
>![[../images/11/yara_activity_install_dpkg.png|Installing Yara DEB Packages|600]]
>The Mimikatz binary is located at `/usr/share/windows-resources/mimikatz/x64/mimikatz.exe` and needs to be analyzed to identify unique values it has.  The more values found in the binary the greater risk of missing similar malware and the fewer hallmarks the more false positives we could have.  My first action will dump all the strings within the binary.  I pipe the output to "less" and inspect interesting values.  I land on the Windows API crypto BCrypt functions because Mimikatz needs this to pull hashed passwords out of LSAS.
>```bash
>strings /usr/share/windows-resources/mimikatz/x64/mimikatz.exe | less
>/BCrypt
>```
>![[../images/11/yara_activity_strings.png|Mimikatz Strings Result|600]]
>Relying only on BCrypt strings for the Yara rule will likely cause many false positives as several legitimate executables may use the functions.  Yara also supports scanning of hexadecimal code signatures.  Using `hexeditor`, navigate to offset 1382E0 using `CTRL+T` and identify a snippet of hex that is a good candidate to identify Mimikatz.  I copy the value to my clipboard to use in my rule.
>```bash
>hexeditor /usr/share/windows-resources/mimikatz/x64/mimikatz.exe 
>CTRL+T
>1382E0
>```
>![[../images/11/yara_activity_hex.png|Hexeditor Offset 1382E0|600]]
>With the string and hex identified, I am ready to write my Yara rule.  I create a file named `mimikatz.yar` with a section that informs Yara strings and hexadecimal code to find.  There is also a condition section that qualifies which strings need to be present for the rule to trigger.
>```bash
>nano mimikatz.yar
>```
>Code used in mimikatz.yar
>```yara
>rule mimikatz_x64_exe 
>{
>  strings: 
>      $hex = { 4C 8B DF 49  C1 E3 04 48   8B CB 4C 03  D8 00 00 00 } 
>      $string = "BCrypt" nocase 
>  condition: 
>      all of them 
>}
>```
>![[../images/11/yara_activity_rule.png|Mimikatz Yara Rule|600]]
>With the rule created I am ready to run it against the file system and detect any malicious Mimikatz files.  Instead of running Yara against the entire file system, I focus the scan on a directory where I know there is at least one hit.
>```bash
>sudo yara -r mimikatz.yar /usr/share/windows-resources
>```
>![[../images/11/yara_activity_run.png|Run Yara Rule|600]]
>After running Yara I have three hits!  Looks like Mimikatz is embedded in a couple DLL files too!
### Malware Analysis
It can be a challenge to assess if a given piece of software is benign or malicious.  End users often inquire from security professionals if a software is safe to use.  Many security systems may also flag software as suspicious and suggest they be investigated further to determine its intent.  Many security professionals and malware analysts have to conduct such checks regularly in larger organizations.  If they are incorrect in their assessment, they may inadvertently block useful non-malicious software or falsely determine a true piece of malicious software is benign and allow it to persist on systems and the network.  Analysts use careful scrutiny when analyzing software in question by using various techniques and tools to draw reasonable conclusions.

Malware performs various activity such as writing files to disc, performing memory operations, establishing network connections, and interfacing with operating system APIs.  Many non-malicious software also performs these same activities; however, the way these activities are conducted may be more suspicious with malware.  The combination of many of these activities could lend itself as another indicator that a software is malicious.  Within Windows systems, malware often leaves *artifacts*, or information and files used by the malware, within the system's drives and memory.  Common places to search for these artifacts are within running processes in memory, services, the Registry's keys, startup directories and autoruns, portable executables and dynamic link libraries, and the task scheduler.  Recall in the Persistence and Privilege Escalation chapter that we explored many of these features and learned how they can be used to store information and execute code.  Malware takes advantage of these features in order to persist and cause its defined impact.

>[!info] Info - Malicious File Types
>The following sections will focus on executables; however, many other file types could contain malware.  These file types are usually a precursor or initial stage that eventually downloads and executes a malicious binary.  Other common file types that could be malicious include, but not limited to, ISOs, MS Office files like Word and Excel, PDFs, and even email files like EML.  Each file type may have its own techniques to safely analyze and interested readers should do more research on analysis methods for a given file type.
### Static Analysis
The safest method of analyzing suspicious software is via **static analysis** where the subject file is not executed but is assessed using tools that avoid running the file.  Opening a PDF in a PDF reader like Adobe Reader could run arbitrary JavaScript code embedded within the file.  It is therefore a prudent practice to avoid executing or opening files when assessing them for malicious code.  Analysts avoid this through the use of inspection tools that can show elements of how the software might behave it is run.

Many Windows based malware is a portable executable (PE) also known as an executable (EXE) file type that is executed when opened.  Such software is built using common dynamic link libraries (DLL), like the `Kernel.dll` that imports useful functions like writing files, updating memory space, and making network connections.  These DLLs and functions are typically written in a higher language like C++ and then compiled into a binary.  Opening a binary file using a text editor will display mostly non-human readable text as the binary will usually consist of non-ASCII hexadecimal code.  However, the binary will have many recognizable characters and often large sections or blocks of human readable characters.  The `strings` utility in Linux systems and embedded as a feature in many Windows based analysis tools, dumps all consecutive ASCII representable bytes to standard output.  Many of these strings will include the names of functions from DLLs, and variables among other useful information that are used by the malware.  These names and values could give a strong indication on the types of activities the malware might perform.  For example, the `VirtualAllocEx` function name could be identified using `strings` which indicates that the software may allocate new memory space in an open process.  This could be an indication that the executable will seek to store malicious code within memory or hijack a running legitimate process.

PEs include *sections* defined by headers that organize the compiled binary.  The sections are explained below:

1. `.text` section stores the assembled code of the program;
2. `.data` has initialized data used by the program;
3. `.idata` includes the imported symbols (names) of DLLs;
4. `.rdata` consists of read only initialized data; and 
5. `.rsrc` sections contains resources used by the binary such as icons, menus, dialogs, version information, fonts, and others.   

The data and resource sections of the malware may contain blocks of code that have been obfuscated, using a number of methods, to avoid detection by antivirus scanners.  This could mean that the data has been encrypted and will result in a block of data that has high entropy or randomness.  

>[!tip] Tip - Indicators
>Because malware shares so many features with benign software, it can be challenging to rely on any single indicator to determine if a subject software is malicious.  Therefore, it is common to evaluate all indicators at the end of an assessment to determine if software may be malicious.

The resource section should also be evaluated closely for nonstandard resources and characteristics such as its file type signature.  For instance, a resource could contain a zip file (PKZIP) that is obfuscated through compression.  Resources of interest would be extracted, unzipped, and then its contents evaluated further.  Malicious software might hide an executable within a zipped resource that is inflated and executed when the parent malware runs.  A great tool for analyzing portable executables using the methods described in the last few paragraphs is `PEStudio`.  The following screenshot is from `PEStudio` analyzing the `calc.exe` application in Windows.

![[../images/11/pestudio.png|PEStudio Analysis of Calculator App|650]]

It is compelling to analyze the `.text` section in greater detail since it stores the assembled code which can help an analyst to understand how the executable might behave.  The binary can be loaded into a *reverse engineering* tool, such as IDA or Ghidra, that *disassembles* the binary into assembly language.  Because assembly can be difficult to read, the disassembled code could also be *decompiled* into C where it could be relatively easier to read and comprehend the types of behavior the software possesses.  Decompilers won't generate code to its original state as when the code was written.  Much of the information used in the higher level program, such as names of variables and functions, will be lost as they do not persist in a compiled binary.  In their place are arbitrary names that the decompiler assigns which don't give any behavioral context.  For example, a malware author might write a function called `executeRansomware` but when compiled and then decompiled by the analyst the function might look like `function_abc123`.  Therefore, reverse engineering decompiled code requires the analyst to rename functions and variables as they learn what they do.  From there, the analyst can gain a deeper understanding of what the program does and whether it is malicious.
### Dynamic Analysis
Another method of analysis is where the suspect file is executed and its activities are observed which is known as **dynamic analysis**.  This analysis is particularly useful when static analysis efforts do not conclusively determine if the software is safe.  For instance, if the data sections have high entropy it could be an indication that the data used in the program is encrypted which doesn't determine if the subject software is malicious.  Decrypting that data section may be too difficult to do statically, but the running software must decrypt that data section at some point during its execution in order to make use of the data.  Dynamic analysis is a shortcut to attempting to statically reverse engineer a program's behavior.  But running suspicious software in a live environment will likely infect the machine so certain precautions have to be taken.  Setting up a dedicated testing machine that is safely partitioned away from the rest of the network and devices is called a *sandbox*.  This environment simulates a normal device and will have specialized tools designed to capture changes to the system, disk, and established network connections.

One such tool for Windows systems called RegShot (https://github.com/Seabreg/Regshot) and captures the file system and Registry state before and then after a file is executed.  The two snapshots of the system are then compared and reconciled to show what items have been updated, deleted, and added on the file system and Registry.  Prior to executing the malware in a sandbox environment, the analyst may setup other monitoring tools to capture network traffic like Wireshark.  Any connections to the internet or network would be captured for further analysis post execution of the malware.  Similarly, there are some techniques where an analyst will capture DNS queries and respond to network requests with placeholder information to *defang* or mitigate the impact of the malware when it attempts to download additional data or files.

The Sysinternals toolset includes a tool called Process Monitor that operates much like the native Windows Task Manager, except it collects much more data on processes, registry changes, file changes, and network connections.  Unlike Task Manager, Process Monitor retains every request and includes a powerful filtering feature that enables analysis that sorts and discovers valuable insights on the malware's behavior.  Running malware in a sandbox environment is a quick way to analyze a file's behavior when executed but it isn't the only way to dynamically analyze software.

![[../images/11/process_monitor.png|Running Process Monitor|600]]

Malware analysts can use software *debuggers* such as x64dbg and Immunity which attach to running software and reveals the CPU registers and memory space (stack and heap) of the malware.  Analysts can then walk through the execution of the malicious program in granular steps assessing each assembly instruction to determine its behavior and architecture.  Other features include the ability to set break points and to patch or modify the malware as it runs.  
### Anti-Analysis
In order to persist undiscovered for as long as possible, malware authors will design their malicious software to evade detection from automated systems like antivirus.  This can be as simple as encoding or encrypting malicious sections of the software.  Another common bypass is to make the file size larger then the maximum file size antivirus will scan.  Microsoft Defender's current file size scanning limit is 2 GB. [^3]  Malware can even hide itself in plain sight by using  common file and process names that would be quickly dismissed by someone investigating.  Malware can even hijack a legitimate running process by removing that process's code and data in memory and replacing it with malicious code which is known as *process hollowing*.

However, at some point a security professional may be alerted to suspicious activity and collect the malware sample for analysis.  As covered in the previous section, the analyst will use a sandbox account and static or dynamic analysis tools.  Malware authors can anticipate their malware might be discovered and may attempt to hide the malware's activities or otherwise slow down analyst's investigations using **anti-analysis** techniques.  One such method is to *pack* the binary which compresses its content into a reduced form making analysis more difficult.  It is similar to a JavaScript minifier which can reduce the size of the file and make it much more difficult for a human to read.  Most popular packing software has an inflation algorithm that can be used to reverse the effects of packing; however, this could cause a stumbling block for a less experienced analyst.  The malware author could use other tactics to obfuscate the binary's features by encoding data sections or variables, inserting non-executable or junk code, or any number of other code manipulation techniques.  [^4]

>[!tip] Tip - Malware Analysis Workstation
>Most security professionals will use a dedicated virtual machine on an isolated host in a segmented network to perform malware analysis on.  This is to avoid incidental infections from spreading to other devices and networks.

Some malware is designed to detect if it is running in an analyst's lab by first checking if it is being run in a virtual machine.  It will look for common virtualization drivers installed in the operating system or it might cycle through names of files on the desktop looking for common malware analysis tools.  If the malware detects any of these patterns, it shuts down gracefully or runs a benign feature avoiding the execution of malicious code.  This will avoid several dynamic analysis techniques.  However, the analysis can overcome this obstacle by loading the software into a debugger and bypassing any such checks.

Even more sophisticated malware authors understand this and also implement checks to verify the running malware is not running in a debugger.  One of the first paths of execution will check Windows API usage of the `IsDebuggerPresent` flag or similar flags and functions.  If this flag is true then the malware shuts down causing the debugger to crash.

> [!activity] Activity 11.3 - Malware Analysis
> The WannaCry ransomware leveraged wormable SMB vulnerabilities to rapidly spread across the globe in 2016.  In this activity I will use online resources to statically and dynamically analyze WannaCry.  I will be in close proximity to this malware so it is best to use my Windows VM with the NAT network mode that allows access to the internet.  Take caution if you decide to download a sample as mishandling it may result in a ransomware infection.
> 
> After starting my Windows VM in bridge adapter network mode, I open Edge and navigate to Virus Total (https://www.virustotal.com/gui/home/search).  Within the search bar I enter the MD5 hash value of a sample file and run the search.
> ```
> 84c82835a5d21bbcf75a61706d8ab549
> ```
> ![[../images/11/analysis_activity_vt_search.png|Searching VirusTotal|600]]
> Upon hitting enter, VirusTotal looks up the hash value against a database of malware scans it has.  If the system has never analyzed the file it would return no results.  An option from there is to upload the file to VirusTotal where it runs a virus scan using 70+ popular anti-malware vendor tools before serving the summary results.  This result from the file would then be available to any registered user so think before you upload sensitive files.  This hash I searched for has an alarming number of vendor reported malware hits who reference the name of this malware as WannaCry.
> ![[../images/11/analysis_activity_vt_hits.png|VirusTotal Summary Results|600]]
> Traditional virus scan tools investigate against a known malicious hash database but we can also perform basic static analysis techniques using VirusTotal.  Navigating to the Details tab reveals several properties about the file such as the tools used to compiled the binary and when the program was created.  This file was compiled and packed using Visual C++ and is confirmed to be a Win32 EXE file type.
> ![[../images/11/analysis_activity_vt_basic.png|VirusTotal Basic Property Results|600]]
> We can also analyze the file's sections alongside their entropy ratings, which could indicate that the file has been packed or encrypted.  Entropy scores greater than 6, up to 8, may indicate an anti-analysis technique is being used to avoid detection.  The static analysis within VirusTotal also shows which Windows DLL imports are used along with any functions within the binary.  Knowing what functions are commonly used in various types of malware helps the analyst determine if a binary could be malicious.  Executables that create files and processes may be benign, but these are also common activities malware performs. [^2]
> ![[../images/11/analysis_activity_vt_imports.png|VirusTotal Imports Details|600]]
> Another fantastic resource to investigate malware is the site Any.run.  This organization offers free dynamic sandbox malware analysis and shares results of any submitted file.  Like VirusTotal, previous submissions can be searched for using the hash of a file or the user can submit a new file for analysis and availability to the community.  Next, I navigate to https://app.any.run/submissions and search `wannacry`.
> ![[../images/11/analysis_activity_any_search.png|Any.Run WannaCry Search|600]]
> Seems there are a few hundred hits on this search.  I opened the first 6 results and found one that matches the MD5 hash used in VirusTotal.  The results screen main pane displays screenshots from the activity performed when running the file.  Within this sample, the WannaCry encryption message is displayed indicating the malware infection.  Underneath the main pane is the network activity pane which lists the HTTP, DNS, and other network connections made while running the executable file.  This section includes an option to download the packet capture for further analysis.  The pane on the right of the screen includes summary information, along with the ability to export or download the sample, as well as the processes that started when running the file.  These processes show the activity performed by the malware such as file creation and memory changes.
> ![[../images/11/analysis_activity_any_result.png|Any.Run WannaCry Analysis Results|600]]
> While VirusTotal and Any.Run are powerful free online tools, proper investigations should be conducted on a malware analysis VM owned by the analyst and using tools similar to the ones that these online tools would use.  It is beyond the scope of this textbook to learn to use these tools in detail but interested readers are encouraged to learn more on this topic!

## Exercises
>[!exercise] Exercise 11.1 - Forensic Investigation
>In this task you will complete various tasks against an acquired USB image from EnCase using Autopsy on your Windows VM in Bridge Adapter network mode.  You will likely need to increase the Windows VM CPU core count (4) and RAM size (6GB) for the software to run smoothly.  Make sure to revert these settings after the lab.
>#### Step 1 - Install Autopsy
>Within the Windows VM, open a browser, navigate to [https://www.autopsy.com/download/](https://www.autopsy.com/download/) and download the latest Windows 64-bit installer.  The browser may block the installer so make sure to "keep" the installer and then expand the Show More dropdown and "Keep anyway".
>
>Once downloaded, run the installer by double clicking the MSI file in your Downloads folder.  Make sure to run it once as nothing may happen for 30 seconds.  Windows SmartScreen may block the installer, make sure to expand the "More info" to display the "Run anyway" button.
>
>The Autopsy Setup wizard will start.  Follow the steps and accept the defaults and UAC prompts until the software is fully installed.  Make sure to Allow any Java installations when prompted.
>#### Step 2 - Case Setup
>With Autopsy installed, run the application from the Desktop shortcut and Create a New Case.  Name the case "USB Drop", set the Base Directory in a folder on your Desktop, and assign a case number.
>
>Save the `forensics.E01` file to your Windows VM and Add Data Source as a "Disk Image or VM File".  Select the `forensics.E01` as the Data Source path and select all Ingest Modules.  Once added wait a couple minutes for the analysis to complete by observing the status bar in the bottom right corner of Autopsy.
>
>Once the ingest modules have been fully analyzed, expand the Directory Tree's Data Sources hierarchy and confirm the drives folders are displayed (eg "American", "Pictures", and other folders).
>#### Step 3 - Analyze USB
>Analyze the data source by finding the following evidence using the search features (upper right corner) and the tree pane module results.  Make sure to provide a screenshot and description of HOW and WHERE you found the evidence.
>- 2 Email Addresses 
>- 2 URLs  
>- 2 Phone Numbers    
>- 1 Zip File 
>- 1 JPG Metadata 
>- 1 PDF Magic Byte Hex Code 
>- 1 File with an Extension Mismatch
>#### Step 4 - Carve Deleted File
>Find a deleted file (tree) and carve/export (right-click) the file locally to your forensics workstation.  Identify the file type, meta data, and its contents.

>[!exercise] Exercise 11.2 - Malware Detection
>Yara is a malware detection tool supported by a large opensource and commercial community. The tool enables an analyst to quickly create a ruleset that can be used to detect malicious software. In this task you will create a custom Yara rule to identify a malicious file using your Kali VM running in Bridge Adapter network mode.
>#### Step 1 - Install Yara
>In your Kali VM, launch a terminal, update your system, and install Yara using the following commands.
>```bash
>wget https://ftp.debian.org/debian/pool/main/y/yara/libyara9_4.2.3-4_amd64.deb
>wget https://ftp.debian.org/debian/pool/main/y/yara/yara_4.2.3-4_amd64.deb
>sudo dpkg -i libyara9_4.2.3-4_amd64.deb
>sudo dpkg -i yara_4.2.3-4_amd64.deb
>```
>Verify Yara installed by running the help menu and reviewing its capabilities.
>```bash
>yara --help
>```
>#### Step 2 - Analyze Known Malware
>We will analyze the local copy of `mimikatz.exe` installed on your Kali VM. Mimikatz is a Windows credential dumping utility used to extract Windows passwords and is often integrated in other malware. The 64 bit executable is located at the following path on your Kali VM "`/usr/share/windows-resources/mimikatz/x64/mimikatz.exe`".
>
>Identify a string that can be used in our Yara rule. Run the `strings` tool on the file and pipe to the `less` utility to identify Windows API crypto functions. BCrypt API functions are used by Windows to perform cryptographic operations which are also used by Mimikatz to extract passwords/hashes. Type "`/BCrypt`" while in the less editor and press enter.   Press "`q`" to exit `less` when satisfied.
>```bash
>strings /usr/share/windows-resources/mimikatz/x64/mimikatz.exe | less
>/BCrypt
>```
>Next, identify some hexcode in the `mimikatz.exe`. Using `hexeditor`, identify a unique section of shellcode. While in the editor, go to offset `1382E0` by pressing "`CTRL+T`" and enter the offset value. This snippet of hexcode may be a good candidate to fingerprint Mimikatz. Copy this hex line to use in our Yara. Press "`CTRL+C`" to exit the editor once finished.
>```bash
>hexeditor /usr/share/windows-resources/mimikatz/x64/mimikatz.exe
>```
>#### Step 3 - Create Custom Yara Rule
>Create a yara ruleset in a file called `mimikatz.yar` that uses the string and hex code identified in the previous step. Use the following template and your favorite text editor. The strings section informs the `yara` tool which strings and hexcode to find in a given file. The condition section qualifies which strings need to be present for the rule to trigger.  Make sure to replace `HEX_CODE_HERE` with the hexcode you found in `hexeditor` from the previous step.
>```bash
>nano mimikatz.yar
>```
>And enter the following code into mimikatz.yar.
>```yara
>rule mimikatz_x64_exe 
>{ 
>	strings: 
>		$hex = { HEX_CODE_HERE } 
>		$string = "BCrypt" nocase 
>	condition: 
>		all of them 
>} 
>```
> #### Step 4 - Find Malware Using Yara
> With the rule created, run `yara` on the "`/usr/share/windows-resources`" directory recursively to identify all files that contain the subject string and hexcode. Files listed indicate a match.
> ```bash
> sudo yara -r mimikatz.yar /usr/share/windows-resources
> ```

>[!exercise] Exercise 11.3 - Malware Analysis
>The WannaCry ransomware leveraged wormable SMB vulnerabilities to rapidly spread across the globe in 2016. In this lab you will use online resources to statically and dynamically analyze WannaCry. You will be in close proximity to this malware so it is best to use one of your VMs with the NAT network mode. Take caution if you decide to download a sample as mishandling it may result in a ransomware infection.
>#### Step 1 - Static Analysis
>Navigate to [https://www.virustotal.com/gui/home/search](https://www.virustotal.com/gui/home/search) , enter the MD5 hash "`84c82835a5d21bbcf75a61706d8ab549`", and observe most AV vendors identify the hash as WannaCry. 
>
>Select the Details tab and review the properties. Observe what tools compiled the program and when it was created.
>#### Step 2 - Dynamic Analysis
>Navigate to [https://app.any.run/submissions](https://app.any.run/submissions) and type "`wannacry`" in the search bar. Observe several submissions populate with the MD5 hash "`84c82835a5d21bbcf75a61706d8ab549`". 
>
>Select one of the submissions to review the already ran dynamic analysis results. Cycle through the screenshots to visually see how the malware behaved. Note, some submissions may only contain one; cycle through submissions until you find one that looks the most interesting. 
>
>Observe the malware's behavior on the right pane. You should be able to see the process trees created and the commands ran in the background. 
>
>Investigate the Network activities in the bottom pane. Discover what connections were made while the malware rand. 
>
>Review the Files activity in the bottom pane and determine what files were read and written to. Any file that ends in "`.mnry`" extension has been encrypted by the malware.
>#### Step 3 - Explore More Malware
>Navigate to [https://app.any.run](https://app.any.run/) public submissions section and find a user submission that identifies malware. Perform your own Static and Dynamic analysis using VirusTotal and the already submitted sample in Any.Run. Describe the malware's properties and behavior in a short report.

[^1]: The history of malware: A primer on the evolution of cyber threats - IBM Blog; IBM; March 31, 2024; https://www.ibm.com/blog/malware-history/
[^2]: Common API used in Malware; HackTricks; April 6th, 2024; https://book.hacktricks.xyz/reversing/common-api-used-in-malware
[^3]: Malware scanning in Microsoft Defender for Storage - Microsoft Defender for Cloud; Microsoft; April 6th, 2024; https://learn.microsoft.com/en-us/azure/defender-for-cloud/defender-for-storage-malware-scan
[^4]: Most Common Malware Obfuscation Techniques - Security Investigation; SOC Investigation; April 6th, 2024; https://www.socinvestigation.com/most-common-malware-obfuscation-techniques/