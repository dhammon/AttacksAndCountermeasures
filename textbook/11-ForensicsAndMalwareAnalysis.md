# Forensics and Malware Analysis
![](forensics.png)

This is the first of two chapters that will cover information security detection and response.  Security operations, or secops, consists of people, processes, and technologies that attempt to monitor systems that will detect security events and incidents.  Once detected and validated, efforts must be made to respond to threats by removing and recovering from security incidents.  This chapter will explore the various types of malicious software and how to analyze them to determine what they might do.  We will also introduce digital forensics techniques and tools used to collect digital evidence and conclude activities performed on systems.

**Objectives**
1. Understand the general overview, and analysis of, digital forensics processes.
2. Conduct a forensic investigation with Autopsy.
3. Describe malware types and analysis techniques.
4. Perform detection methods and analysis of malware.
## Forensics
Part of the security function at organizations is to investigate a variety of cases including security incidents and verification of activities on computer systems.  **Digital forensics** is the investigation of electronic systems, such as storage media, operating systems, and log sources, to determine some activity with reasonable certainty.  This sub-discipline of information includes processes such as the collection, preservation, validation, analysis, and conclusions of evidence gathered from digital sources.  This section will identify the types of cases, the investigatory process, data acquisition processes, media types, and forensic tools including the popular Autopsy case management software. 

>[!information] Info - Guide to Computer Forensics and Investigations
>If this subject interests the reader, I highly recommend Bill Nelson, Amelia Phillips, and Christopher Steuart's Guide to Computer Forensics and Investigations textbook (ISBN: 9780357688595).
### Public Case Types
The variety of case scenarios is wide ranging and their outcomes depend on whether the case is *public* or *private* sectors.  Public cases pertain to a criminal element where there are authorities attempting to prosecute a crime.  The *digital investigator* assists law enforcement investigations by gathering and analyzing digital evidence.  In addition, prosecuting or defense attorneys may hire digital investigators to validate law enforcement investigations and identify exculpatory (absolve) or inculpatory (incriminates) evidence.  

The collection of evidence in public investigations is restricted, in the United States, by the 4th Amendment which defines search and seizers.  Generally, evidence may only be collected where there is probably cause, a search warrant, or court order.  Only the material, persons, and place defined in warrants and court orders may be seized to be used in a public forensic investigation. 

Public cases range in the types of technologies used as just about any technology could be used as part of a crime.  In addition, many crimes involve some type of digital technology such as, but not limited to, telecommunications over smart phones, digital cameras, as well as workstations and laptops.
### Private Case Types
Organizations also perform digital investigations which are known as private sector cases.  The goal of these cases is rarely criminal prosecution as organization typically want to limit risk.  This risk could include financial loss caused by reputational damage, theft, or other malicious activity.  Private cases may result in civil court where forensics investigators could be hired by attorneys on both sides; however, most cases do not rise to this level as civil records are available to the public and most companies try to avoid the negative publicity.  

Most members or employees of an organization do not have a right to privacy, at least in the United States, which means that investigators have access to almost any data needed to conduct investigations.  This not only includes a subject's devices but the server logs they may have communicated with.  Typically such invasion is allowable due to a company's acceptable use policy which defines that all activity performed on company devices and digital assets is owned by the employer and is actively monitored.

Private cases may be centered around employee theft of intellectual data, data breaches, and human resource issues to name a few.  Usually a company's computer and technology base is focused and homogenous, in that there are a limited number of device types and software used which allows the investigator to have a more focused skillset.  For example, a business may only have Windows 11 operating systems on workstations which exempts the investigator from having to know MacOS or Linux forensics techniques.
### Investigatory Process
Proper handling of investigations is paramount to ensuring a thorough and well vetted conclusion for a case.  Forensic investigators should apply a methodical approach and adhere to a linear **investigation process** that ensures the integrity of the evidence and analysis.  These efforts must start before a case event begins, a *preparation* phase, as the investigator should be well prepared with knowledge, skillset, tooling, and workspace.  Forensic professionals should be well trained in common forensic techniques and methods by completing certifications and attending industry conferences.  This will expose the professional to the latest trends in technology and the tools available to assist with investigations.  

The investigator must also have a reasonable workspace that ensures digital evidence is well protected - such as a dedicated office space and fireproof locking file cabinet.  This office, or *forensics lab*, should have access restricted to only those with a need to know and be equipped with the hardware and software needed to perform investigations.  Hardware includes workstations powerful enough to handle multiple input/output devices, drives, disc cloners, write blockers, and portable forensic devices.  A physical toolset that includes items like screwdrivers and various cabling that might be needed during an investigation must also be available prior to commencing an investigation.  Lastly, the software tools to collect and analyze evidence securely must be procured and installed to support the investigation.

After preparation, the next step in the investigatory process is the *acquisition* of evidence.  During this time the investigator will collect physical devices and media, make forensic copies, and inventory the items collected.  It is crucial that the evidence collected is secured at all times to avoid the corruption or mishandling of data that could jeopardize a case's integrity.  Once evidence is collected and forensic copies are made, the next step is *validation* where original data sources are confirmed to exactly match with forensic copies made.  Validation is performed using a hashing algorithm where if even a one bit difference would cause a very different hash output.

>[!info] Info - AccessData's FTK Imager
>A very popular professional data acquisition tool is AccessData's FTK imager which allows you to make image copies of attached drives.  The following screenshot is a sample of the user interface exploring an image and starting an image copy process.
>![[../images/11/ftk_imager.png|FTK Imager Drive Copying|500]]

Forensic investigators work off of digital copies of source material as to avoid inadvertently corrupting or changing the original evidence.  These copies are used in the *investigation* phase of the process where a case is prepared, the evidence is analyzed relative to the scenario, and notes are taken that will drive an investigation.  Every case is different, but usually the investigator has some context of what is being reviewed.  For example, an employee harassment claim might include a collection of emails to be analyzed or an intellectual property theft case may require the analysis of a hardware drive.

After the investigation, where digital evidence is identified and tagged in case management software, the *reporting* step aggregates the methods of the investigation, description of evidence collected, and conclusions made from analyzing the evidence.  This last step typically results in a formal written document which may be used as *testimony* in a court setting.
### Data Acquisition
A serious component of digital forensics is the collection of evidence or **data acquisition**.  While the investigator will obtain a device's storage media, investigations are usually not performed directly on the device if it can be avoided.  This is because any activity the investigator performs on the device could corrupt the original storage data and lose it's repudiation.  Even powering a device on will update timestamps on the operating system and file system which overwrites potentially important data to the investigation.  Therefore, an investigator will produce one, or more, forensic copies of the original data source.

Prior to making a copy of a subject storage media, the investigator will prepare a target drive to copy data onto.  This drive must have capacity large enough to accommodate the copied data.  It must also be free of any other data, especially malware.  Typically the investigator would securely wipe the target drive using a tool such as *Derek's boot and nuke (DBAN)*.  This software overwrites every bit on the drive zeroing out any contents in one or more iterations.  Once a target drive is clean, it can be initialized, partitioned, and a file system mounted on it, such as Microsoft's NTFS.  Alternatively, a drive could be securely wiped and then used to clone the subject storage media using device cloner hardware or software like *data dump (dd)*.  Once prepared the drive is ready to accept incoming files including image files (ISO).

There are several collection methods to consider depending on the context of a case.  Disk to image collection takes a single file image copy of a subject disk.  Disk to disk collection makes a bit for bit copy of the subject drive onto the target drive otherwise known as cloning.  Many investigations may not require the compete drive and may instead rely on the collection of specific files, such as the PST database of a user's email box.  When collecting only particular files the collection methodology is referred to as a *logical* acquisition.  Finally, some storage media may be too large to collect a disk image from such as the case with *redundant array of independent disks (RAID)* systems.  Therefore an investigator may choose the *sparse* collection method where only sections of a disk are acquired onto a target drive.

Investigators must also determine whether to use a live or a static acquisition type depending on the circumstances of an investigation.  *Static* collections are taken from storage media while the device is powered off.  An example of this type is removing a drive from a workstation and cloning it.  Investigators should use a *write blocker* hardware device or software feature to ensure data is not inadvertently written to the subject drive will performing a static acquisition.  The other type of acquisition to consider is the *live* method which is performed while the device is powered on.  This will have the affect of writing data to the subject drive, which can be mitigated so long as the investigator takes detailed notes and logs all of their activity.  The benefit to live acquisitions is that the investigator will have more information available to them such as processes running in memory and applications currently open.  Another benefit to a live acquisition is that it could be the only way to retrieve files to investigate if the storage media is encrypted by the device owner.  A password or key is required to decrypt drive contents which might not be shared with an investigator so performing a live acquisition on a device already powered on and decrypted could be the only way to ensure evidence is collected.

>[!info] Info - Write Blocker
>Write blockers are a vital tool used by forensic investigators to ensure data is not inadvertently written to a subject drive.
>![[../images/11/write_blocker.png|Write Blocker Connected to Hard Drive|400]]
>Credit: https://en.wikipedia.org/wiki/Forensic_disk_controller

Other considerations investigators must make is performing the acquisition onsite or remotely.  In most cases the acquisition is conducted onsite, meaning the investigator is physically present relative to the storage media.  However the investigator could perform an acquisition remotely which is a type of live acquisition where data can be sent over a network to the investigator.  Remote acquisitions are very common in private sector cases as employee computers have preinstalled remote access tooling.  This tooling enables administrators and security professionals to access a device ad hoc and copy any needed files or drives.

Acquisitions result in one or more files being created for the investigation.  While the collected data could be from logical acquisitions and include graphic files, documents, or databases, disk acquisitions produce image or disk files.  An entire drive can be collected into a single file with a specific extension depending on the type of acquisition software use to create this file.  The most common and versatile image or disk file format is the raw format.  Most acquisition and investigation software supports the creation, or analysis, of raw files.  However, some commercial grade forensics software prepares forensic copies using proprietary formats that is less supported across the software ecosystem.  While being less flexible, these proprietary systems include additional features not supported by the raw format, such as logging, compression, file splitting, and validations. 

The generalized process of the acquisition phase of an investigation can be summarized as follows:
1. Preparing the target drive;
2. Acquiring the subject media;
3. Connecting the subject media to a write blocker;
4. Making a forensic copy;
5. Validating the subject drive and forensic copies match;
6. Logging evidence *chain of custody*; and 
7. Securely storing the evidence to be used later during the investigation phase.

Once evidence is collected, the next phase of the case can begin where the forensic investigator analyzes the contents of the drive or files.
### Analysis Types
There are several types of digital forensic analysis types that investigators perform.  The objectives of each case will depend heavily on the context and circumstances surrounding why the investigation was requested.  Often investigators are requested to prove or disprove some activity on a device which offers some insights as to where and what to look for.  Many investigations are straight forward evidence is relatively simple to observe.  For instance, in an email investigation, the forensics professional may identify the subject email on the system or from an email server.  However, the investigator must ensure with some level of confidence the authenticity of the email such as by reviewing the email's header information and comparing ESMTP IDs to those on an email server confirming the email was not fabricated or manipulated.

Some investigations center around the analysis of storage media, such as hard drives.  These investigations may search for deleted files proving target information was on the drive.  When a user deletes a file, such as through the operating system's file deletion feature, the file system simply updates the file table by marking that space on the drive as available for writing new files.  The deletion action does not remove the data of that file from the disk and a forensic investigator could retrieve part or all of that file after it has been deleted.  Data can also be recovered from a file's *slack space* which is the space on the drive from the logical end of the file to the end of the sector.  Sectors are usually 512 bytes and support only one file at a time.  A file can consume several sectors, groups called *clusters*, but the last sector will likely not be fully used.  The slack space of a file could contain the remnants of previous files or may contain data purposefully hidden.  Drive partitions, where file systems are installed, are labeled with a partition name and assigned a drive letter in Microsoft Windows.  But a partition might not be initialized by the operating system and could otherwise be invisible to casual users.  An investigator may search a drive seeking to identify any hidden partitions to identify additional files of interest.

> [!warning] Warning - Anti-forensics
> I've have already mentioned a couple techniques where data could be purposefully hidden. Such efforts are known as *anti-forensics* techniques and investigators must be not only aware of them but also how to overcome them to ensure a comprehensive investigation. 

Another type of analysis focuses on the file system installed on subject drives.  There are many types and versions of file systems which vary depending on the type of operating system using them.  Windows devices now use the *new technology file system (NTFS)* but used *file allocation table (FAT)* versions in the past.  Linux commonly uses the *extended file system version 4 (EXT4)* while Apple has the *Apple file system (APFS)*.  Both Linux and Apple systems also support older file systems and versions.  All file systems generally work the same way by organizing how files are stored and utilized on a disk.  The file system is like a map used by an operating system to manage files.  An investigator must understand how these systems work and where subject data could be stored.  For example, file systems keep track of areas on the disk that have bad sectors (or blocks) to avoid reads and writes that corrupt a file.  A subject may attempt to hide data in a cluster and then update the file system's bad sector table to include the sectors where they stashed evidence.

Many file types can be the subject of interest in an investigation where the professional analyzes a file's contents.  One technique investigators will use is identifying file extension mismatches of the file header or magic bytes.  The magic byte of a file is the specific hex code at the beginning of the file that allows an application to identify the file is of the correct type for processing.  Identifying files by their magic bytes ensures they real file type that could be of material interest to an investigation.

Operating systems (OS) are the means which most users interact with a device and conduct their activity.  The major OSs Windows, Linux, and MacOS track system and user activity in various ways.  For instance, Windows systems have a *registry* which is a configuration database the operating system and applications use to store information used in various processes.  The registry is rich with data that includes information such as the last time a program may have been ran and by which user.  Such information could be highly valuable to an investigation.  For live acquisitions and investigations the contents of a system's *random access memory (RAM)* can be collected and analyzed known as *memory forensics*.  Here the investigator dumps memory content from a powered on device to review the running programs or processes contents.

Cases may require the analysis of networks as well.  In these cases log activity is collected from network devices such as routers and firewalls to be analyzed.  Investigators will identify subject activity performed on the network related to the case.  These investigations could include a packet capture which could be analyzed in great detail within Wireshark even going as far as extracting files that were transferred over a network.
### Forensic Software Tools
The primary activities in digital forensics is the acquisition and then analysis of evidence.  There are many software tools that support both these efforts.  Only well vetted software tools should be used as part of an investigation as the professional will need to place reliance to ensure a quality review as well as the validity and accuracy of any tool could come under later scrutiny.  Therefore, investigators should use tools that are highly reputable and well supported.

In an earlier section we covered the acquisition phase of a case.  Two common software tools used are Linux's native *data dump (dd)* and AccessData's FTK imager.  They support the creation of forensic copies and are widely used in the industry.  DD is a command line utility that can take bit for bit copies of storage systems into a raw format.

The organization of cases and analysis of data are supported by analysis software such as the opensource Autopsy or commercial OSForensics by PassMark; although there are many other reputable software's supporting specific technologies that could be more appropriate.  Both Autopsy and OSForensics offer features such as case management where evidence can be logically separated from other cases while being assigned to specific investigators or teams.  Other features include modules designed to ingest a data source and automate the identification of evidence through scanning.  For instance, either tool can detect and recover files that have been deleted or identify hidden partitions on a disk.  These tools can also create timelines and generate reports that can save time and increase quality of investigation outcomes.


>[!activity] Activity 11.1 - Forensic Investigation
>In this activity I will demonstrate the analysis of a subject forensic image using Autopsy for Windows.  I'll use the Windows VM and install the Autopsy which is free and opensource.  Then I'll create a case, load the source image, and run analysis ingestion modules that will identify areas of interest.  From there I will manually enumerate features hunting for potential evidence using many of the features built into the application.
>
>Once the Windows VM is fully started, I open the Edge browser, navigate to https://www.autopsy.com/download/ and and download the Autopsy MSI.
>![[../images/11/forensic_activity_autopsy_download.png|Downloading Autopsy Installer|450]]
>After the MSI downloads I double click it to initiate the installation process.  This required me to accept warning messages from Edge security and Windows Smart Screen.  Once running I accept UAC prompts and use the default or recommended installation settings.  Eventually the Autopsy installation completes and a shortcut is added to my Desktop.  Double clicking the shortcut launches Autopsy to the following screen.
>![[../images/11/forensics_activity_autopsy_started.png|Autopsy Launched|650]]
>I select New Case and enter a case name of "USB Drop" then provide the path to my Desktop folder where the case files will be stored.
>![[../images/11/forensic_activity_case_info.png|Entering Case Information|650]]
>After pressing next I supply a case number as well as my name under the Examiner field before hitting the Finish button.  This action creates the case files locally on my Desktop.
>![[../images/11/forensics_activity_case_info_2.png|Other Case Information|650]]
>The next step is adding the data source which I've already downloaded onto my Windows VM.  The file `forensics.E01` was acquired using Encase software and contains a file system from a USB drive.  This investigation requires me to examine the contents of the USB.  I'm first prompted to generate a host name, which I leave to the default, then I press Next.  I then leave the data source type as "Disk Image or VM File" and hit Next.  Afterwards I chose the path of the forensics.E01 file and press Next again.
>![[../images/11/forensics_activity_data_source.png|Choosing Data Source Path|500]]
>The Configure Ingest step lists all the ingestion modules available to run against the data source.  These preinstalled modules will analyze the image and identify various areas of interest.  All modules are selected by default so I hit the Next button and after a few moments the Finish button.
>![[../images/11/forensics_activity_modules.png|Ingestion Module Selection|650]]
>While the ingestion module run in the background I am presented with the Autopsy application's main work window.  The left most pane provides a navigation pane that includes the data source drive as well as the results from the ingestion modules.  The right top pane lists folder contents selected from the navigation pane whereas the right bottom pane displays the content and addition information of selected files from the right top pane.  There is also a progress bar in the bottom right corner which shows the level of completion for the ingestion modules.
>![[../images/11/forensics_activity_autopsy.png|Autopsy Main Window|650]]
>I can navigate the data source drive by expanding the Data Sources tree and selecting folders of interest.
>![[../images/11/forensics_activity_drive_review.png|Review Drive Contents|400]]
>Autopsy comes with a keyword search and built-in regular expression patterns as part of the keyword list feature in the upper right corner of the application.  
>![[../images/11/forensics_activity_keyword_list.png|Keyword Lists Search Feature|400]]
>Selecting Phone Numbers and running a search results in the identification of every file that has a known phone number pattern in its files contents.  This advance searching allows an investigator to quickly identify files of potential interest.
>![[../images/11/forensics_activity_phone_search.png|Phone Number Search Results|600]]
>Autopsy ingest modules also identify file types and aggregates them as a quick reference in the navigation pane.  Here I can find specific file types such as zip files.
>![[../images/11/forensics_activity_file_types.png|File Type Aggregation|550]]
>One way a person might attempt to obfuscate files is to change the file extension so that the OS identifies the file as an incorrect type.  However, Autopsy can find file extension mismatches and drops them in the navigation pane.  The MIME type of this file is JPEG but its extension is a DAT file!
>![[../images/11/forensics_activity_mismatch.png|Mismatch File Type Detection|650]]
>Files, including previously deleted files, can be recovered from forensic images using Autopsy.  Under File View in the left navigation pane is a Deleted Files type.  Expanding this tree shows all the files that were previously deleted that are still recoverable.  Selecting a file and right-clicking it displays the context menu with the Extract Files option.
>![[../images/11/forensics_activity_deleted_files.png|Deleted Files Recovery|650]]
>Extracting the file, or file *carving*, will save a copy to my case folder on my desktop where it can be further examined using other tools.
>![[../images/11/forensics_activity_carving.png|Carved File|350]]
>There are many more features in Autopsy that extend beyond the scope of this activity.  The tool is very powerful and enables forensic investigators to quickly parse through an image and find interesting files.
>
## Malicious Software
Software that performs unwanted and ill-natured behavior is referred to as **malicious software** or malware for short.  They a written by malicious actors with the intent of inducing some harm on the device it is ran on.  This section of the chapter explores the types and behaviors of malware as well as some methods of detecting and analyzing what the malware does.  Having a clear understanding of malware enables security professionals to better protect organization systems from threats as malware is often used during security intrusions.

The threat landscape for malicious software has only increased and matured as a result of financial incentives, societal reliance on technology, and the lack of accountability to identify and punish malicious actors.  While the idea of a lone malicious actor still exists, the most threatening attackers band together in desperate groups supported by sophisticated marketplaces.  The *darknet*, accessible through The Onion Router (TOR) encrypted networks, provide threat actors with anonymity and digital communities to offer tradecraft, communications, and commerce all with mal intent.  Nowadays, independent attackers specialize in specific fields such as *initial access brokers* who compromise user accounts to sell to other attackers.  Those who purchase initial access may register with a malicious vendor like a *ransomware as a service* "company" as an affiliate.  Ransomware operators sell customer support services and employ or purchase ransomware malware from third party developers.  All these actors working independently and yet together to cause havoc to victims.
### Types of Malware
Malware has its history dating as far back as the mid 60's when computer scientists theorized on how software could be designed to self replicate.  The first widely publicized attempt at creating a self reproducing piece of software was developed in 1971 known as the Creeper worm.  By the early to mid 80's malicious software started to appear coinciding with the rise of the personal computer. [^1]  By the late 80's the first anti-virus solution, McAfee, hit the market with the aim to identify and mitigate known malicious software.  The volume of malware increased with the popularity of the internet in the mid 90's as more consumers began to rely on computer systems to conduct personal and commercial tasks.  As computer and network systems, and the systems to thwart malware, grew in complexity so did the types and amount of malicious software.  These days the rate of new malware grows exponentially as society becomes more reliant on computer systems and the opportunity for malicious software authors' reward increase.

>[!tip] Tip - Potentially Unwanted Program
>Some antivirus solutions will also detect *potentially unwanted programs (PUP)*, especially within corporate environments, for software that might not be useful to the organization.

As technology expands and there is more incentive to abuse digital systems, the volume of malware continues to increase.  In this rise of malicious software patterns begin to emerge that allow for the categorization of malware into types or classes that define their behavior.  A **worm** can self reproduce spreading to new systems in an autonomous manner.  They can be particularly devastating as their spread quickly becomes uncontrolled.  **Spyware** is another class of malicious software designed to monitor system activity it is installed on and report back to information like device location, files or images created, and applications used.  Typically spyware attempts to keep a low profile as the authors don't want it being detected so it can continue its collection of data.  One type of spyware is a *keylogger* which will log every keystroke received from a keyboard.  Within this captured data is sensitive data like banking details and secrets like passwords.

Some malware's impact is fairly benign and has a relatively low impact to a user's system.  For example, **adware** is a type of malware that serves or injects ads to a user in an attempt to collect revenue from an internet advertisement agency.  There are many other advertisement abuse schemes designed to bilk money from ad services like Google which may not affect a user's device.  Some malicious actors even advertise malware cloaked as legitimate software through advertisers in the hopes that a victim will click on the **advertisement** and download some malicious software.  Continuing on the financial motive of malware authors introduces *carding* malware which is designed to steal credit card information.  One type of carding software is *Magecart* which affects ecommerce platforms and skims credit card information to be used or sold on the darknet.

Newer financially incentive malware leverages the anonymity and value of crypto currencies.  Although the concept behind **ransomware** predates the creation of crypto currencies, it has become wildly popular malware type starting in the early 2010s.  Ransomware encrypts data with a key that only the attacker has and a demand for payment, in anonymous crypto currency, is made in exchange for the decryption key.  This extortion can be compounded if the attacker also exfiltrates the files before they encrypt them wherein the attacker then also demand additional payment to not release the files onto the internet.  Organizations often face the ethical dilemma of whether to pay the ransom to attempt recovering their operations, having to trust the malicious actors technology and commitment, versus further incentivizing the propagation and use of ransomware on future victims as every payment made is validation to the malicious actors to continue their malicious business model.  Another type of malware gaining popularity due to the creation and valuations of cryptocurrencies are **cryptominers**.  This malware infects a device and runs software that mines for cryptocurrencies.  Given the primary cost of cryptominers is electricity, the attackers enjoy the proceeds of mining without experiencing the electrical costs the victims are expected to pay from their utility companies.

>[!info] Info - As a File or Fileless
>Malware can be many types of files, really anything that runs code.  However, malware that exists and runs only in memory, so called *fileless malware*, also exists.  Such malware can be difficult to detect using traditional antivirus solutions.

An attacker may want to gain remote access to a victim in which case they could use malware called **trojan** named after the Greek mythology wooden horse used to conquer the city of Troy.  The Msfvenom payloads used in the Security Testing chapter are tojans, also referred to as *remote access tojans (RAT)*, that gives the attacker full system control.  Some malicious actors work to compromise many devices, sometimes tens of thousands, into a robot army called a *botnet*.  These botnets are then used to perform *distributed denial of service (DDoS)* attacks on a victim where each bot performs continuous network requests against a single target overwhelming the victim and causing the system to crash or otherwise be unavailable to legitimate users.
### Malware Behavior
Most malware infections start with a victim downloading a malicious file or app from the internet in one form or another.  This includes files included or referenced in phishing emails, browser extensions, mobile applications, or any other source of file or application a person may be tempted to download and run on their device.  Wherever there is an opportunity to run code or an executable, there is a malicious actor designing malware to be used in that vector.

The simplest form of malware could be a file that runs a malicious command; however, this type of threat is usually easily detected by modern anti-malware systems.  As a result of these security controls, malware authors have expanded the complexity of how malware behaves often to avoid detection and analysis.  Most infections will start with some initial vector that could be a file that has been compressed, encrypted, or prepared to avoid detection through firewalls or email systems.  When the victim opens this initial file a *loader* or *dropper* is ran which retrieves another malicious file.  This file could be heavily obfuscated, again to avoid detection and analysis, but when it is ran it could download yet another download, known as a *stage*.  Any number of stages could flow through this process until the final malicious payload is deployed on the system.

>[!tip] Tip - Anti-analysis
>Malicious actors go to great lengths to dissuade security professionals from analyzing their malware in an attempt to evade further detection or to hide true intensions.  Such efforts are called *anti-analysis* and can present a series of challenges to malware analysis professionals to disect how a malicious software operates. 

Once the malware takes hold it could have several objectives.  Some malware may attempt to hide itself throughout the operating system, or embed itself into the master boot record known as a *bootkit*.  The goal would be to establish some persistence in case the malware's process is terminated, by a reboot for example.  Some wormable malware may seek to pivot to other network devices or seek to infect removable storage devices like cellular phones or USB drives.  The final stage could even be self wiping or destruction where the malware deletes or removes all traces of its activities from logs, any file artefacts created from proceeding stages, and even remove itself.
### Detecting Malware
The first efforts to detect and remove malware used static hashes, such as MD5, of files on a device and compared them to a database of hashes for known malware.  If there was a hash match the file would be considered malicious and quarantined or removed from the system.  While this worked well, and still has its place in modern security, it can be easily bypassed with small modifications to the original file.  In addition, under the **static hash detection** technique, novel malware is undetectable.

The countermeasure to malware authors slightly modifying existing malware avoiding hash detection is to check specific characteristics of a malicious file.  These characteristics are organized into rules that are fed into a detection engine.  They look for things like strings and hexadecimal code values at specific offsets in a file known as the **fingerprinting detection** technique.  A very popular opensource to for detecting malware this way is Yara.  Malware analysist and security researchers studying malware behavior will write Yara rules and publish them for public consumption and subscriptions to rulesets.

However, malicious actors can also subscribe to these rulesets and modify their malware to specifically evade detection.  It is possible to derive these rules even if one does not have access to the rule.  For example, if Mimikatz, used for dumping secrets in a Windows system LSAS process and memory, was downloaded to Windows that had Defender enabled it would immediately be detected and removed.  Taking that Mimikatz binary and breaking it into several smaller files would reveal some file fragments being identified and removed and others not.  Then breaking those blocked fragments into even smaller files and repeating the steps over until the specific offending string or hexadecimal code is identified that Defender takes issue with will reveal what needs to be modified to bypass the antivirus solution.

Advanced antimalware solutions hook into every processes' memory space and inspects running application's activities.  This **anomalous behavior detection** technique antimalware, sometimes referred to as *endpoint detection and response (EDR)*, monitors running programs behavior such as file system activity, API calls, and network connections that are commonly associated with malicious processes.  This has the distinct advantage over static and fingerprinting techniques since it does not rely on specific data and instead is heuristically based.  However, it too can be bypassed using several methods including those demonstrated in the Operating System Security anti-virus bypass activity.

>[!activity] Activity 11.2 - Malware Detection
>Yara is a malware detection tool supported by a large opensource and commercial community.  It is common for malware researchers to create Yara rules for novel malware that is shared and distributed through subscription feeds.  Using the Kali virtual machine, I will create a Yara rule to detect Mimikatz which comes preinstalled on the file system.
>
>After powering on Kali and opening a terminal, I install Yara using apt.
>```bash
>wget https://ftp.debian.org/debian/pool/main/y/yara/libyara9_4.2.3-4_amd64.deb
>wget https://ftp.debian.org/debian/pool/main/y/yara/yara_4.2.3-4_amd64.deb
>```
>Once download both DEB files, I install them using dpkg.
>```bash
>sudo dpkg -i libyara9_4.2.3-4_amd64.deb
>sudo dpkg -i yara_4.2.3-4_amd64.deb
>```
>![[../images/11/yara_activity_install_dpkg.png|Installing Yara DEB Packages|600]]
>The Mimikatz binary is located at `/usr/share/windows-resources/mimikatz/x64/mimikatz.exe` and needs to be analyzed to identify unique values it has.  The more values found in the binary the greater risk of missing similar malware and the fewer hallmarks the more false positives we could have.  My first action will dump all the strings within the binary.  I pipe the output to "less" and inspect interesting values.  I land on the Windows API crypto BCrypt API functions because Mimikatz needs this to pull hashed passwords out of LSAS.
>```bash
>strings /usr/share/windows-resources/mimikatz/x64/mimikatz.exe | less
>/BCrypt
>```
>![[../images/11/yara_activity_strings.png|Mimikatz Strings Result|600]]
>Relying only on BCrypt strings for the Yara rule will likely cause many false positives as many legitimate executables may use the functions.  Yara also supports scanning of hexadecimal code signatures.  Using hexeditor, navigate to offset 1382E0 using `CTRL+T` and identify a snippet of hex that is a good candidate to identify mimikatz.  I copy the value to my clipboard to use in my rule.
>```bash
>hexeditor /usr/share/windows-resources/mimikatz/x64/mimikatz.exe 
>CTRL+T
>1382E0
>```
>![[../images/11/yara_activity_hex.png|Hexeditor Offset 1382E0|600]]
>With the string and hex identified, I am ready to write my Yara rule.  I create a file named mimikatz.yar with a string section that informs Yara strings and hexadecimal code to find.  There is also a condition section that qualifies which strings need to be present for the rule to trigger.
>```bash
>nano mimikatz.yar
>```
>Code used in mimikatz.yar
>```yara
>rule mimikatz_x64_exe 
>{
>  strings: 
>      $hex = { 4C 8B DF 49  C1 E3 04 48   8B CB 4C 03  D8 00 00 00 } 
>      $string = "BCrypt" nocase 
>  condition: 
>      all of them 
>}
>```
>![[../images/11/yara_activity_rule.png|Mimikatz Yara Rule|600]]
>With the rule created I am ready to run it against the file system and detect any malicious Mimikatz files.  Instead of running Yara against the entire file system, I focus the scan on a directory where I know there is at least one hit.
>```bash
>sudo yara -r mimikatz.yar /usr/share/windows-resources
>```
>![[../images/11/yara_activity_run.png|Run Yara Rule|600]]
>After running Yara I have three hits!  Looks like Mimikatz is embedded in a couple DLL files too!

### Malware Analysis
Analyzing Systems
Static Analysis
Dynamic Analysis
Anti-Analysis
### Analysis Tooling
Malware Analysis Workstation
Online Resources
Static Analysis Tools
Dynamic Analysis Tools

> [!activity] Activity 11.3 - Malware Analysis

## Exercises
>[!exercise] Exercise 11.1 - Forensic Investigation
>In this task you will complete various tasks against an acquired USB image from EnCase software using Autopsy on your Windows VM in Bridge Adapter network mode.  You will likely need to increase the Windows VM CPU core count (4) and RAM size (6GB) for the software to run smoothly.  Make sure to revert these settings after the lab.
>#### Step 1 - Install Autopsy
>Within the Windows VM, open a browser and navigate to [https://www.autopsy.com/download/](https://www.autopsy.com/download/) and download the latest Windows 64-bit installer.  The browser may block the installer, make sure to "keep" the installer and then expand the Show More dropdown and "Keep anyway".
>
>Once downloaded, run the installer by double clicking the MSI file in your Downloads folder.  Make sure to run it once as nothing may happen for 30 seconds.  Windows SmartScreen may block the installer, make sure to expand the "More info" to display the "Run anyway" button.
>
>The Autopsy Setup wizard will start.  Follow the steps accepting the defaults and UAC prompts until the software is fully installed.  Make sure to Allow any Java installations when prompted.
>#### Step 2 - Case Setup
>With Autopsy installed, run the application from the Desktop shortcut and Create a New Case.  Name the case "USB Drop", set the Base Directory in a folder on your Desktop, and assign a case number.
>
>Save the forensics.E01 file to your Windows VM and Add Data Source as a "Disk Image or VM File".  Select the forensics.E01 as the Data Source path and select all Ingest Modules.  Once added wait a couple minutes for the analysis to complete by observing the status bar in the bottom right corner of Autopsy to complete.
>
>Once ingest modules have been fully analyzed, expand the Directory Tree's Data Sources hierarchy and confirm the drives folders are displayed (eg "American", "Pictures", and other folders).
>#### Step 3 - Analyze USB
>Analyze the data source by finding the following evidence using the search features (upper right corner) and the tree pane module results.  Make sure to provide a screenshot and description of HOW and WHERE you found the evidence.
>- 2 Email Addresses 
>- 2 URLs  
>- 2 Phone Numbers    
>- 1 Zip File 
>- 1 JPG Metadata 
>- 1 PDF Magic Byte Hex Code 
>- 1 File with an Extension Mismatch
>#### Step 4 - Carve Deleted File
>Find a deleted file (tree) and carve/export (right-click) the file locally to your forensics workstation.  Identify the file type, meta data, and its contents.

>[!exercise] Exercise 11.2 - Malware Detection
>Yara is a malware detection tool supported by a large opensource and commercial community. The tool enables an analyst to quickly create a ruleset that can be used to detect malicious software. In this task you will create a custom Yara rule to identify a malicious file using your Kali VM running in Bridge Adapter network mode.
>#### Step 1 - Install Yara
>In your Kali VM, launch a terminal, update your system, and install yara using apt.
>```bash
>sudo apt update -y
>sudo apt install yara -y
>```
>Verify yara installed by running the help menu and reviewing its capabilities.
>```bash
>yara --help
>```
>#### Step 2 - Analyze Known Malware
>We will analyze the local copy of mimikatz installed on your Kali VM. Mimikatz is a Windows credential dumping utility used to extract Windows passwords and is often integrated in other malware. The 64 bit executable is located at the following path on your Kali VM "/usr/share/windows-resources/mimikatz/x64/mimikatz.exe".
>
>Identify a string that can be used in our Yara rule. Run the "strings" tool on the file and pipe to the "less" utility to identify Windows API crypto functions. BCrypt API functions are used by Windows to perform cryptographic operations which are also used by Mimikatz to extract passwords/hashes. Type "/BCrypt" while in the less editor and press enter.   Press "q" to exit less when satisfied.
>```bash
>strings /usr/share/windows-resources/mimikatz/x64/mimikatz.exe | less
>/BCrypt
>```
>Next, identify some hexcode in the mimikatz.exe. Using hexeditor, identify a unique section of shellcode. While in the editor, go to offset 1382E0 by pressing "CTRL+T" and enter the offset value. This snippet of hexcode may be a good candidate to fingerprint mimikatz. Copy this hex line to use in our Yara. Press "CTRL+C" to exit the editor once finished.
>```bash
>hexeditor /usr/share/windows-resources/mimikatz/x64/mimikatz.exe
>```
>#### Step 3 - Create Custom Yara Rule
>Create a yara ruleset in a file called mimikatz.yar that uses the string and hex code identified in the previous step. Use the following template and your favorite text editor. The strings section informs the yara tool which strings and hexcode to find in a given file. The condition section qualifies which strings need to be present for the rule to trigger.  Make sure to replace HEX_CODE_HERE with the hexcode you found in hexeditor from the previous step.
>```bash
>nano mimikatz.yar
>```
>And enter the following code into mimikatz.yar.
>```yara
>rule mimikatz_x64_exe 
>{ 
>	strings: 
>		$hex = { HEX_CODE_HERE } 
>		$string = "BCrypt" nocase 
>	condition: 
>		all of them 
>} 
>```
> #### Step 4 - Find Malware Using Yara
> With the rule created, run yara on the "/usr/share/windows-resources" directory recursively to identify all files that contain the subject string and hexcode. Files listed indicate a match.
> ```bash
> sudo yara -r mimikatz.yar /usr/share/windows-resources
> ```

>[!exercise] Exercise 11.3 - Malware Analysis
>The WannaCry ransomware leveraged wormable SMB vulnerabilities to rapidly spread across the globe in 2016. In this lab you will use online resources to statically and dynamically analyze WannaCry. You will be in close proximity to this malware so it is best to use one of your VMs with the NAT network mode. Take caution if you decide to download a sample as mishandling it may result in a ransomware infection.
>#### Step 1 - Static Analysis
>Navigate to [https://www.virustotal.com/gui/home/search](https://www.virustotal.com/gui/home/search) , enter the MD5 hash "84c82835a5d21bbcf75a61706d8ab549", and observe most AV vendors identify the hash as WannaCry. 
>
>Select the Details tab and review the properties. Observe what tools compiled the program and when it was created.
>#### Step 2 - Dynamic Analysis
>Navigate to [https://app.any.run/submissions](https://app.any.run/submissions) and type "wannacry" in the search bar. Observe several submissions populate with the MD5 hash "84c82835a5d21bbcf75a61706d8ab549". 
>
>Select one of the submissions to review the already ran dynamic analysis results. Cycle through the screenshots to visually see how the malware behaved. Note, some submissions may only contain one; cycle through submissions until you find one that looks the most interesting. 
>
>Observe the malware's behavior on the right pane. You should be able to see the process trees created and the commands ran in the background. 
>
>Investigate the Network activities in the bottom pane. Discover what connections were made while the malware rand. 
>
>Review the Files activity in the bottom pane and determine what files were read and written to. Any file that ends in ".mnry" extension has been encrypted by the malware.
>#### Step 3 - Explore Any.Run
>Navigate to [https://app.any.run](https://app.any.run/) public submissions section and find a user submission that identifies malware. Perform your own Static and Dynamic analysis using VirusTotal and the already submitted sample in Any.Run. Describe the malware's properties and behavior in a short report.

[^1]: The history of malware: A primer on the evolution of cyber threats - IBM Blog; IBM; March 31, 2024; https://www.ibm.com/blog/malware-history/