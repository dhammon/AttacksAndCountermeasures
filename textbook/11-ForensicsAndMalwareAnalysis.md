# Forensics and Malware Analysis
![](forensics.png)

This is the first of two chapters that will cover information security detection and response.  Security operations, or secops, consists of people, processes, and technologies that attempt to monitor systems that will detect security events and incidents.  Once detected and validated, efforts must be made to respond to threats by removing and recovering from security incidents.  This chapter will explore the various types of malicious software and how to analyze them to determine what they might do.  We will also introduce digital forensics techniques and tools used to collect digital evidence and conclude activities performed on systems.

**Objectives**
1. Understand the general overview, and analysis of, digital forensics processes.
2. Conduct a forensic investigation with Autopsy.
3. Describe malware types and analysis techniques.
4. Perform detection methods and analysis of malware.
## Forensics
Part of the security function at organizations is to investigate a variety of cases including security incidents and verification of activities on computer systems.  **Digital forensics** is the investigation of electronic systems, such as storage media, operating systems, and log sources, to determine some activity with reasonable certainty.  This sub-discipline of information includes processes such as the collection, preservation, validation, analysis, and conclusions of evidence gathered from digital sources.  This section will identify the types of cases, the investigatory process, data acquisition processes, media types, and forensic tools including the popular Autopsy case management software. 

>[!information] Info - Guide to Computer Forensics and Investigations
>If this subject interests the reader, I highly recommend Bill Nelson, Amelia Phillips, and Christopher Steuart's Guide to Computer Forensics and Investigations textbook (ISBN: 9780357688595).
### Public Case Types
The variety of case scenarios is wide ranging and their outcomes depend on whether the case is *public* or *private* sectors.  Public cases pertain to a criminal element where there are authorities attempting to prosecute a crime.  The *digital investigator* assists law enforcement investigations by gathering and analyzing digital evidence.  In addition, prosecuting or defense attorneys may hire digital investigators to validate law enforcement investigations and identify exculpatory (absolve) or inculpatory (incriminates) evidence.  

The collection of evidence in public investigations is restricted, in the United States, by the 4th Amendment which defines search and seizers.  Generally, evidence may only be collected where there is probably cause, a search warrant, or court order.  Only the material, persons, and place defined in warrants and court orders may be seized to be used in a public forensic investigation. 

Public cases range in the types of technologies used as just about any technology could be used as part of a crime.  In addition, many crimes involve some type of digital technology such as, but not limited to, telecommunications over smart phones, digital cameras, as well as workstations and laptops.
### Private Case Types
Organizations also perform digital investigations which are known as private sector cases.  The goal of these cases is rarely criminal prosecution as organization typically want to limit risk.  This risk could include financial loss caused by reputational damage, theft, or other malicious activity.  Private cases may result in civil court where forensics investigators could be hired by attorneys on both sides; however, most cases do not rise to this level as civil records are available to the public and most companies try to avoid the negative publicity.  

Most members or employees of an organization do not have a right to privacy, at least in the United States, which means that investigators have access to almost any data needed to conduct investigations.  This not only includes a subject's devices but the server logs they may have communicated with.  Typically such invasion is allowable due to a company's acceptable use policy which defines that all activity performed on company devices and digital assets is owned by the employer and is actively monitored.

Private cases may be centered around employee theft of intellectual data, data breaches, and human resource issues to name a few.  Usually a company's computer and technology base is focused and homogenous, in that there are a limited number of device types and software used which allows the investigator to have a more focused skillset.  For example, a business may only have Windows 11 operating systems on workstations which exempts the investigator from having to know MacOS or Linux forensics techniques.
### Investigatory Process
Proper handling of investigations is paramount to ensuring a thorough and well vetted conclusion for a case.  Forensic investigators should apply a methodical approach and adhere to a linear **investigation process** that ensures the integrity of the evidence and analysis.  These efforts must start before a case event begins, a *preparation* phase, as the investigator should be well prepared with knowledge, skillset, tooling, and workspace.  Forensic professionals should be well trained in common forensic techniques and methods by completing certifications and attending industry conferences.  This will expose the professional to the latest trends in technology and the tools available to assist with investigations.  

The investigator must also have a reasonable workspace that ensures digital evidence is well protected - such as a dedicated office space and fireproof locking file cabinet.  This office, or *forensics lab*, should have access restricted to only those with a need to know and be equipped with the hardware and software needed to perform investigations.  Hardware includes workstations powerful enough to handle multiple input/output devices, drives, disc cloners, write blockers, and portable forensic devices.  A physical toolset that includes items like screwdrivers and various cabling that might be needed during an investigation must also be available prior to commencing an investigation.  Lastly, the software tools to collect and analyze evidence securely must be procured and installed to support the investigation.

After preparation, the next step in the investigatory process is the *acquisition* of evidence.  During this time the investigator will collect physical devices and media, make forensic copies, and inventory the items collected.  It is crucial that the evidence collected is secured at all times to avoid the corruption or mishandling of data that could jeopardize a case's integrity.  Once evidence is collected and forensic copies are made, the next step is *validation* where original data sources are confirmed to exactly match with forensic copies made.  Validation is performed using a hashing algorithm where if even a one bit difference would cause a very different hash output.

>[!info] Info - AccessData's FTK Imager
>A very popular professional data acquisition tool is AccessData's FTK imager which allows you to make image copies of attached drives.  The following screenshot is a sample of the user interface exploring an image and starting an image copy process.
>![[../images/11/ftk_imager.png|FTK Imager Drive Copying|500]]

Forensic investigators work off of digital copies of source material as to avoid inadvertently corrupting or changing the original evidence.  These copies are used in the *investigation* phase of the process where a case is prepared, the evidence is analyzed relative to the scenario, and notes are taken that will drive an investigation.  Every case is different, but usually the investigator has some context of what is being reviewed.  For example, an employee harassment claim might include a collection of emails to be analyzed or an intellectual property theft case may require the analysis of a hardware drive.

After the investigation, where digital evidence is identified and tagged in case management software, the *reporting* step aggregates the methods of the investigation, description of evidence collected, and conclusions made from analyzing the evidence.  This last step typically results in a formal written document which may be used as *testimony* in a court setting.
### Data Acquisition
A serious component of digital forensics is the collection of evidence or **data acquisition**.  While the investigator will obtain a device's storage media, investigations are usually not performed directly on the device if it can be avoided.  This is because any activity the investigator performs on the device could corrupt the original storage data and lose it's repudiation.  Even powering a device on will update timestamps on the operating system and file system which overwrites potentially important data to the investigation.  Therefore, an investigator will produce one, or more, forensic copies of the original data source.

Prior to making a copy of a subject storage media, the investigator will prepare a target drive to copy data onto.  This drive must have capacity large enough to accommodate the copied data.  It must also be free of any other data, especially malware.  Typically the investigator would securely wipe the target drive using a tool such as *Derek's boot and nuke (DBAN)*.  This software overwrites every bit on the drive zeroing out any contents in one or more iterations.  Once a target drive is clean, it can be initialized, partitioned, and a file system mounted on it, such as Microsoft's NTFS.  Alternatively, a drive could be securely wiped and then used to clone the subject storage media using device cloner hardware or software like *data dump (dd)*.  Once prepared the drive is ready to accept incoming files including image files (ISO).

There are several collection methods to consider depending on the context of a case.  Disk to image collection takes a single file image copy of a subject disk.  Disk to disk collection makes a bit for bit copy of the subject drive onto the target drive otherwise known as cloning.  Many investigations may not require the compete drive and may instead rely on the collection of specific files, such as the PST database of a user's email box.  When collecting only particular files the collection methodology is referred to as a *logical* acquisition.  Finally, some storage media may be too large to collect a disk image from such as the case with *redundant array of independent disks (RAID)* systems.  Therefore an investigator may choose the *sparse* collection method where only sections of a disk are acquired onto a target drive.

Investigators must also determine whether to use a live or a static acquisition type depending on the circumstances of an investigation.  *Static* collections are taken from storage media while the device is powered off.  An example of this type is removing a drive from a workstation and cloning it.  Investigators should use a *write blocker* hardware device or software feature to ensure data is not inadvertently written to the subject drive will performing a static acquisition.  The other type of acquisition to consider is the *live* method which is performed while the device is powered on.  This will have the affect of writing data to the subject drive, which can be mitigated so long as the investigator takes detailed notes and logs all of their activity.  The benefit to live acquisitions is that the investigator will have more information available to them such as processes running in memory and applications currently open.  Another benefit to a live acquisition is that it could be the only way to retrieve files to investigate if the storage media is encrypted by the device owner.  A password or key is required to decrypt drive contents which might not be shared with an investigator so performing a live acquisition on a device already powered on and decrypted could be the only way to ensure evidence is collected.

>[!info] Info - Write Blocker
>Write blockers are a vital tool used by forensic investigators to ensure data is not inadvertently written to a subject drive.
>![[../images/11/write_blocker.png|Write Blocker Connected to Hard Drive|400]]
>Credit: https://en.wikipedia.org/wiki/Forensic_disk_controller

Other considerations investigators must make is performing the acquisition onsite or remotely.  In most cases the acquisition is conducted onsite, meaning the investigator is physically present relative to the storage media.  However the investigator could perform an acquisition remotely which is a type of live acquisition where data can be sent over a network to the investigator.  Remote acquisitions are very common in private sector cases as employee computers have preinstalled remote access tooling.  This tooling enables administrators and security professionals to access a device ad hoc and copy any needed files or drives.

Acquisitions result in one or more files being created for the investigation.  While the collected data could be from logical acquisitions and include graphic files, documents, or databases, disk acquisitions produce image or disk files.  An entire drive can be collected into a single file with a specific extension depending on the type of acquisition software use to create this file.  The most common and versatile image or disk file format is the raw format.  Most acquisition and investigation software supports the creation, or analysis, of raw files.  However, some commercial grade forensics software prepares forensic copies using proprietary formats that is less supported across the software ecosystem.  While being less flexible, these proprietary systems include additional features not supported by the raw format, such as logging, compression, file splitting, and validations. 

The generalized process of the acquisition phase of an investigation can be summarized as follows:
1. Preparing the target drive;
2. Acquiring the subject media;
3. Connecting the subject media to a write blocker;
4. Making a forensic copy;
5. Validating the subject drive and forensic copies match;
6. Logging evidence *chain of custody*; and 
7. Securely storing the evidence to be used later during the investigation phase.

Once evidence is collected, the next phase of the case can begin where the forensic investigator analyzes the contents of the drive or files.
### Analysis Types
There are several types of digital forensic analysis types that investigators perform.  The objectives of each case will depend heavily on the context and circumstances surrounding why the investigation was requested.  Often investigators are requested to prove or disprove some activity on a device which offers some insights as to where and what to look for.  Many investigations are straight forward evidence is relatively simple to observe.  For instance, in an email investigation, the forensics professional may identify the subject email on the system or from an email server.  However, the investigator must ensure with some level of confidence the authenticity of the email such as by reviewing the email's header information and comparing ESMTP IDs to those on an email server confirming the email was not fabricated or manipulated.

Some investigations center around the analysis of storage media, such as hard drives.  These investigations may search for deleted files proving target information was on the drive.  When a user deletes a file, such as through the operating system's file deletion feature, the file system simply updates the file table by marking that space on the drive as available for writing new files.  The deletion action does not remove the data of that file from the disk and a forensic investigator could retrieve part or all of that file after it has been deleted.  Data can also be recovered from a file's *slack space* which is the space on the drive from the logical end of the file to the end of the sector.  Sectors are usually 512 bytes and support only one file at a time.  A file can consume several sectors, groups called *clusters*, but the last sector will likely not be fully used.  The slack space of a file could contain the remnants of previous files or may contain data purposefully hidden.  Drive partitions, where file systems are installed, are labeled with a partition name and assigned a drive letter in Microsoft Windows.  But a partition might not be initialized by the operating system and could otherwise be invisible to casual users.  An investigator may search a drive seeking to identify any hidden partitions to identify additional files of interest.

> [!warning] Warning - Anti-forensics
> I've have already mentioned a couple techniques where data could be purposefully hidden. Such efforts are known as *anti-forensics* techniques and investigators must be not only aware of them but also how to overcome them to ensure a comprehensive investigation. 

Another type of analysis focuses on the file system installed on subject drives.  There are many types and versions of file systems which vary depending on the type of operating system using them.  Windows devices now use the *new technology file system (NTFS)* but used *file allocation table (FAT)* versions in the past.  Linux commonly uses the *extended file system version 4 (EXT4)* while Apple has the *Apple file system (APFS)*.  Both Linux and Apple systems also support older file systems and versions.  All file systems generally work the same way by organizing how files are stored and utilized on a disk.  The file system is like a map used by an operating system to manage files.  An investigator must understand how these systems work and where subject data could be stored.  For example, file systems keep track of areas on the disk that have bad sectors (or blocks) to avoid reads and writes that corrupt a file.  A subject may attempt to hide data in a cluster and then update the file system's bad sector table to include the sectors where they stashed evidence.

Many file types can be the subject of interest in an investigation where the professional analyzes a file's contents.  One technique investigators will use is identifying file extension mismatches of the file header or magic bytes.  The magic byte of a file is the specific hex code at the beginning of the file that allows an application to identify the file is of the correct type for processing.  Identifying files by their magic bytes ensures they real file type that could be of material interest to an investigation.

Operating systems (OS) are the means which most users interact with a device and conduct their activity.  The major OSs Windows, Linux, and MacOS track system and user activity in various ways.  For instance, Windows systems have a *registry* which is a configuration database the operating system and applications use to store information used in various processes.  The registry is rich with data that includes information such as the last time a program may have been ran and by which user.  Such information could be highly valuable to an investigation.  For live acquisitions and investigations the contents of a system's *random access memory (RAM)* can be collected and analyzed known as *memory forensics*.  Here the investigator dumps memory content from a powered on device to review the running programs or processes contents.

Cases may require the analysis of networks as well.  In these cases log activity is collected from network devices such as routers and firewalls to be analyzed.  Investigators will identify subject activity performed on the network related to the case.  These investigations could include a packet capture which could be analyzed in great detail within Wireshark even going as far as extracting files that were transferred over a network.
### Forensic Software Tools
The primary activities in digital forensics is the acquisition and then analysis of evidence.  There are many software tools that support both these efforts.  Only well vetted software tools should be used as part of an investigation as the professional will need to place reliance to ensure a quality review as well as the validity and accuracy of any tool could come under later scrutiny.  Therefore, investigators should use tools that are highly reputable and well supported.

In an earlier section we covered the acquisition phase of a case.  Two common software tools used are Linux's native *data dump (dd)* and AccessData's FTK imager.  They support the creation of forensic copies and are widely used in the industry.  DD is a command line utility that can take bit for bit copies of storage systems into a raw format.

The organization of cases and analysis of data are supported by analysis software such as the opensource Autopsy or commercial OSForensics by PassMark; although there are many other reputable software's supporting specific technologies that could be more appropriate.  Both Autopsy and OSForensics offer features such as case management where evidence can be logically separated from other cases while being assigned to specific investigators or teams.  Other features include modules designed to ingest a data source and automate the identification of evidence through scanning.  For instance, either tool can detect and recover files that have been deleted or identify hidden partitions on a disk.  These tools can also create timelines and generate reports that can save time and increase quality of investigation outcomes.


>[!activity] Activity 11.1 - Forensic Investigation
>In this activity I will demonstrate the analysis of a subject forensic image using Autopsy for Windows.  I'll use the Windows VM and install the Autopsy which is free and opensource.  Then I'll create a case, load the source image, and run analysis ingestion modules that will identify areas of interest.  From there I will manually enumerate features hunting for potential evidence using many of the features built into the application.
>
>Once the Windows VM is fully started, I open the Edge browser, navigate to https://www.autopsy.com/download/ and and download the Autopsy MSI.
>![[../images/11/forensic_activity_autopsy_download.png|Downloading Autopsy Installer|450]]
>After the MSI downloads I double click it to initiate the installation process.  This required me to accept warning messages from Edge security and Windows Smart Screen.  Once running I accept UAC prompts and use the default or recommended installation settings.  Eventually the Autopsy installation completes and a shortcut is added to my Desktop.  Double clicking the shortcut launches Autopsy to the following screen.
>![[../images/11/forensics_activity_autopsy_started.png|Autopsy Launched|650]]
>I select New Case and enter a case name of "USB Drop" then provide the path to my Desktop folder where the case files will be stored.
>![[../images/11/forensic_activity_case_info.png|Entering Case Information|650]]
>After pressing next I supply a case number as well as my name under the Examiner field before hitting the Finish button.  This action creates the case files locally on my Desktop.
>![[../images/11/forensics_activity_case_info_2.png|Other Case Information|650]]
>The next step is adding the data source which I've already downloaded onto my Windows VM.  The file `forensics.E01` was acquired using Encase software and contains a file system from a USB drive.  This investigation requires me to examine the contents of the USB.  I'm first prompted to generate a host name, which I leave to the default, then I press Next.  I then leave the data source type as "Disk Image or VM File" and hit Next.  Afterwards I chose the path of the forensics.E01 file and press Next again.
>![[../images/11/forensics_activity_data_source.png|Choosing Data Source Path|500]]
>The Configure Ingest step lists all the ingestion modules available to run against the data source.  These preinstalled modules will analyze the image and identify various areas of interest.  All modules are selected by default so I hit the Next button and after a few moments the Finish button.
>![[../images/11/forensics_activity_modules.png|Ingestion Module Selection|650]]
>While the ingestion module run in the background I am presented with the Autopsy application's main work window.  The left most pane provides a navigation pane that includes the data source drive as well as the results from the ingestion modules.  The right top pane lists folder contents selected from the navigation pane whereas the right bottom pane displays the content and addition information of selected files from the right top pane.  There is also a progress bar in the bottom right corner which shows the level of completion for the ingestion modules.
>![[../images/11/forensics_activity_autopsy.png|Autopsy Main Window|650]]
>I can navigate the data source drive by expanding the Data Sources tree and selecting folders of interest.
>![[../images/11/forensics_activity_drive_review.png|Review Drive Contents|400]]
>Autopsy comes with a keyword search and built-in regular expression patterns as part of the keyword list feature in the upper right corner of the application.  
>![[../images/11/forensics_activity_keyword_list.png|Keyword Lists Search Feature|400]]
>Selecting Phone Numbers and running a search results in the identification of every file that has a known phone number pattern in its files contents.  This advance searching allows an investigator to quickly identify files of potential interest.
>![[../images/11/forensics_activity_phone_search.png|Phone Number Search Results|600]]
>Autopsy ingest modules also identify file types and aggregates them as a quick reference in the navigation pane.  Here I can find specific file types such as zip files.
>![[../images/11/forensics_activity_file_types.png|File Type Aggregation|550]]
>One way a person might attempt to obfuscate files is to change the file extension so that the OS identifies the file as an incorrect type.  However, Autopsy can find file extension mismatches and drops them in the navigation pane.  The MIME type of this file is JPEG but its extension is a DAT file!
>![[../images/11/forensics_activity_mismatch.png|Mismatch File Type Detection|650]]
>Files, including previously deleted files, can be recovered from forensic images using Autopsy.  Under File View in the left navigation pane is a Deleted Files type.  Expanding this tree shows all the files that were previously deleted that are still recoverable.  Selecting a file and right-clicking it displays the context menu with the Extract Files option.
>![[../images/11/forensics_activity_deleted_files.png|Deleted Files Recovery|650]]
>Extracting the file, or file *carving*, will save a copy to my case folder on my desktop where it can be further examined using other tools.
>![[../images/11/forensics_activity_carving.png|Carved File|350]]
>There are many more features in Autopsy that extend beyond the scope of this activity.  The tool is very powerful and enables forensic investigators to quickly parse through an image and find interesting files.
>
## Malicious Software
Software that performs unwanted and ill-natured behavior is referred to as **malicious software** or malware for short.  They a written by malicious actors with the intent of inducing some harm on the device it is ran on.  This section of the chapter explores the types and behaviors of malware as well as some methods of detecting and analyzing what the malware does.  Having a clear understanding of malware enables security professionals to better protect organization systems from threats as malware is often used during security intrusions.

The threat landscape for malicious software has only increased and matured as a result of financial incentives, societal reliance on technology, and the lack of accountability to identify and punish malicious actors.  While the idea of a lone malicious actor still exists, the most threatening attackers band together in desperate groups supported by sophisticated marketplaces.  The *darknet*, accessible through The Onion Router (TOR) encrypted networks, provide threat actors with anonymity and digital communities to offer tradecraft, communications, and commerce all with mal intent.  Nowadays, independent attackers specialize in specific fields such as *initial access brokers* who compromise user accounts to sell to other attackers.  Those who purchase initial access may register with a malicious vendor like a *ransomware as a service* "company" as an affiliate.  Ransomware operators sell customer support services and employ or purchase ransomware malware from third party developers.  All these actors working independently and yet together to cause havoc to victims.
### Types of Malware
Malware has its history dating as far back as the mid 60's when computer scientists theorized on how software could be designed to self replicate.  The first widely publicized attempt at creating a self reproducing piece of software was developed in 1971 known as the Creeper worm.  By the early to mid 80's malicious software started to appear coinciding with the rise of the personal computer. [^1]  By the late 80's the first anti-virus solution, McAfee, hit the market with the aim to identify and mitigate known malicious software.  The volume of malware increased with the popularity of the internet in the mid 90's as more consumers began to rely on computer systems to conduct personal and commercial tasks.  As computer and network systems, and the systems to thwart malware, grew in complexity so did the types and amount of malicious software.  These days the rate of new malware grows exponentially as society becomes more reliant on computer systems and the opportunity for malicious software authors' reward increase.

>[!tip] Tip - Potentially Unwanted Program
>Some antivirus solutions will also detect *potentially unwanted programs (PUP)*, especially within corporate environments, for software that might not be useful to the organization.

As technology expands and there is more incentive to abuse digital systems, the volume of malware continues to increase.  In this rise of malicious software patterns begin to emerge that allow for the categorization of malware into types or classes that define their behavior.  A **worm** can self reproduce spreading to new systems in an autonomous manner.  They can be particularly devastating as their spread quickly becomes uncontrolled.  **Spyware** is another class of malicious software designed to monitor system activity it is installed on and report back to information like device location, files or images created, and applications used.  Typically spyware attempts to keep a low profile as the authors don't want it being detected so it can continue its collection of data.  One type of spyware is a *keylogger* which will log every keystroke received from a keyboard.  Within this captured data is sensitive data like banking details and secrets like passwords.

Some malware's impact is fairly benign and has a relatively low impact to a user's system.  For example, **adware** is a type of malware that serves or injects ads to a user in an attempt to collect revenue from an internet advertisement agency.  There are many other advertisement abuse schemes designed to bilk money from ad services like Google which may not affect a user's device.  Some malicious actors even advertise malware cloaked as legitimate software through advertisers in the hopes that a victim will click on the **advertisement** and download some malicious software.  Continuing on the financial motive of malware authors introduces *carding* malware which is designed to steal credit card information.  One type of carding software is *Magecart* which affects ecommerce platforms and skims credit card information to be used or sold on the darknet.

Newer financially incentive malware leverages the anonymity and value of crypto currencies.  Although the concept behind **ransomware** predates the creation of crypto currencies, it has become wildly popular malware type starting in the early 2010s.  Ransomware encrypts data with a key that only the attacker has and a demand for payment, in anonymous crypto currency, is made in exchange for the decryption key.  This extortion can be compounded if the attacker also exfiltrates the files before they encrypt them wherein the attacker then also demand additional payment to not release the files onto the internet.  Organizations often face the ethical dilemma of whether to pay the ransom to attempt recovering their operations, having to trust the malicious actors technology and commitment, versus further incentivizing the propagation and use of ransomware on future victims as every payment made is validation to the malicious actors to continue their malicious business model.  Another type of malware gaining popularity due to the creation and valuations of cryptocurrencies are **cryptominers**.  This malware infects a device and runs software that mines for cryptocurrencies.  Given the primary cost of cryptominers is electricity, the attackers enjoy the proceeds of mining without experiencing the electrical costs the victims are expected to pay from their utility companies.

>[!info] Info - As a File or Fileless
>Malware can be many types of files, really anything that runs code.  However, malware that exists and runs only in memory, so called *fileless malware*, also exists.  Such malware can be difficult to detect using traditional antivirus solutions.

An attacker may want to gain remote access to a victim in which case they could use malware called **trojan** named after the Greek mythology wooden horse used to conquer the city of Troy.  The Msfvenom payloads used in the Security Testing chapter are tojans, also referred to as *remote access tojans (RAT)*, that gives the attacker full system control.  Some malicious actors work to compromise many devices, sometimes tens of thousands, into a robot army called a *botnet*.  These botnets are then used to perform *distributed denial of service (DDoS)* attacks on a victim where each bot performs continuous network requests against a single target overwhelming the victim and causing the system to crash or otherwise be unavailable to legitimate users.
### Malware Behavior
Most malware infections start with a victim downloading a malicious file or app from the internet in one form or another.  This includes files included or referenced in phishing emails, browser extensions, mobile applications, or any other source of file or application a person may be tempted to download and run on their device.  Wherever there is an opportunity to run code or an executable, there is a malicious actor designing malware to be used in that vector.

The simplest form of malware could be a file that runs a malicious command; however, this type of threat is usually easily detected by modern anti-malware systems.  As a result of these security controls, malware authors have expanded the complexity of how malware behaves often to avoid detection and analysis.  Most infections will start with some initial vector that could be a file that has been compressed, encrypted, or prepared to avoid detection through firewalls or email systems.  When the victim opens this initial file a *loader* or *dropper* is ran which retrieves another malicious file.  This file could be heavily obfuscated, again to avoid detection and analysis, but when it is ran it could download yet another download, known as a *stage*.  Any number of stages could flow through this process until the final malicious payload is deployed on the system.

>[!tip] Tip - Anti-analysis
>Malicious actors go to great lengths to dissuade security professionals from analyzing their malware in an attempt to evade further detection or to hide true intensions.  Such efforts are called *anti-analysis* and can present a series of challenges to malware analysis professionals to disect how a malicious software operates. 

Once the malware takes hold it could have several objectives.  Some malware may attempt to hide itself throughout the operating system, or embed itself into the master boot record known as a *bootkit*.  The goal would be to establish some persistence in case the malware's process is terminated, by a reboot for example.  Some wormable malware may seek to pivot to other network devices or seek to infect removable storage devices like cellular phones or USB drives.  The final stage could even be self wiping or destruction where the malware deletes or removes all traces of its activities from logs, any file artefacts created from proceeding stages, and even remove itself.
### Detecting Malware
The first efforts to detect and remove malware used static hashes, such as MD5, of files on a device and compared them to a database of hashes for known malware.  If there was a hash match the file would be considered malicious and quarantined or removed from the system.  While this worked well, and still has its place in modern security, it can be easily bypassed with small modifications to the original file.  In addition, under the **static hash detection** technique, novel malware is undetectable.

The countermeasure to malware authors slightly modifying existing malware avoiding hash detection is to check specific characteristics of a malicious file.  These characteristics are organized into rules that are fed into a detection engine.  They look for things like strings and hexadecimal code values at specific offsets in a file known as the **fingerprinting detection** technique.  A very popular opensource to for detecting malware this way is Yara.  Malware analysist and security researchers studying malware behavior will write Yara rules and publish them for public consumption and subscriptions to rulesets.

However, malicious actors can also subscribe to these rulesets and modify their malware to specifically evade detection.  It is possible to derive these rules even if one does not have access to the rule.  For example, if Mimikatz, used for dumping secrets in a Windows system LSAS process and memory, was downloaded to Windows that had Defender enabled it would immediately be detected and removed.  Taking that Mimikatz binary and breaking it into several smaller files would reveal some file fragments being identified and removed and others not.  Then breaking those blocked fragments into even smaller files and repeating the steps over until the specific offending string or hexadecimal code is identified that Defender takes issue with will reveal what needs to be modified to bypass the antivirus solution.

Advanced antimalware solutions hook into every processes' memory space and inspects running application's activities.  This **anomalous behavior detection** technique antimalware, sometimes referred to as *endpoint detection and response (EDR)*, monitors running programs behavior such as file system activity, API calls, and network connections that are commonly associated with malicious processes.  This has the distinct advantage over static and fingerprinting techniques since it does not rely on specific data and instead is heuristically based.  However, it too can be bypassed using several methods including those demonstrated in the Operating System Security anti-virus bypass activity.

>[!activity] Activity 11.2 - Malware Detection
>Yara is a malware detection tool supported by a large opensource and commercial community.  It is common for malware researchers to create Yara rules for novel malware that is shared and distributed through subscription feeds.  Using the Kali virtual machine, I will create a Yara rule to detect Mimikatz which comes preinstalled on the file system.
>
>After powering on Kali and opening a terminal, I install Yara using apt.
>```bash
>wget https://ftp.debian.org/debian/pool/main/y/yara/libyara9_4.2.3-4_amd64.deb
>wget https://ftp.debian.org/debian/pool/main/y/yara/yara_4.2.3-4_amd64.deb
>```
>Once download both DEB files, I install them using dpkg.
>```bash
>sudo dpkg -i libyara9_4.2.3-4_amd64.deb
>sudo dpkg -i yara_4.2.3-4_amd64.deb
>```
>![[../images/11/yara_activity_install_dpkg.png|Installing Yara DEB Packages|600]]
>The Mimikatz binary is located at `/usr/share/windows-resources/mimikatz/x64/mimikatz.exe` and needs to be analyzed to identify unique values it has.  The more values found in the binary the greater risk of missing similar malware and the fewer hallmarks the more false positives we could have.  My first action will dump all the strings within the binary.  I pipe the output to "less" and inspect interesting values.  I land on the Windows API crypto BCrypt API functions because Mimikatz needs this to pull hashed passwords out of LSAS.
>```bash
>strings /usr/share/windows-resources/mimikatz/x64/mimikatz.exe | less
>/BCrypt
>```
>![[../images/11/yara_activity_strings.png|Mimikatz Strings Result|600]]
>Relying only on BCrypt strings for the Yara rule will likely cause many false positives as many legitimate executables may use the functions.  Yara also supports scanning of hexadecimal code signatures.  Using hexeditor, navigate to offset 1382E0 using `CTRL+T` and identify a snippet of hex that is a good candidate to identify mimikatz.  I copy the value to my clipboard to use in my rule.
>```bash
>hexeditor /usr/share/windows-resources/mimikatz/x64/mimikatz.exe 
>CTRL+T
>1382E0
>```
>![[../images/11/yara_activity_hex.png|Hexeditor Offset 1382E0|600]]
>With the string and hex identified, I am ready to write my Yara rule.  I create a file named mimikatz.yar with a string section that informs Yara strings and hexadecimal code to find.  There is also a condition section that qualifies which strings need to be present for the rule to trigger.
>```bash
>nano mimikatz.yar
>```
>Code used in mimikatz.yar
>```yara
>rule mimikatz_x64_exe 
>{
>  strings: 
>      $hex = { 4C 8B DF 49  C1 E3 04 48   8B CB 4C 03  D8 00 00 00 } 
>      $string = "BCrypt" nocase 
>  condition: 
>      all of them 
>}
>```
>![[../images/11/yara_activity_rule.png|Mimikatz Yara Rule|600]]
>With the rule created I am ready to run it against the file system and detect any malicious Mimikatz files.  Instead of running Yara against the entire file system, I focus the scan on a directory where I know there is at least one hit.
>```bash
>sudo yara -r mimikatz.yar /usr/share/windows-resources
>```
>![[../images/11/yara_activity_run.png|Run Yara Rule|600]]
>After running Yara I have three hits!  Looks like Mimikatz is embedded in a couple DLL files too!
### Malware Analysis
It can be a challenge to assess if a given piece of software is benign or malicious.  End users often inquire from security professionals if a software is safe to use.  Many security systems may also flag software as suspicious and needing to be investigated further to determine its intent.  Many security professionals, or malware analysts, have to conduct such checks regularly in larger organizations.  If they are incorrect in their assessment they may inadvertently block useful non-malicious software or event worst may determine a malicious software is benign and allow it to persist on systems and the network.  Analysts must engage with careful scrutiny when analyzing software in question using various techniques and tools to draw reasonable conclusions.

Malware performs various activity such as writing files to disc, performing memory operations, establishing network connections, and interfacing with operating system APIs.  Many non-malicious software also performs these same activities; however, the way these activities are conducted may be more suspicious with malware.  The combination of many of these activities may too lend itself as another indicator that a software is malicious.  Within Windows systems, malware may leave *artifacts*, or information used by the malware, on they system's drive and memory.  Common places to search for these artifacts within running processes in memory, services, the Registry's keys, startup directories and autoruns, portable executables and dynamic link libraries, and the task scheduler.  Recall in the Persistence and Privilege Escalation chapter that we explored many of these features and learned how they can be used to store information and execute code.  Malware takes advantage of these features in order to persist and cause its defined impact.

>[!info] Info - Malicious File Types
>The following sections will focus on executables; however, many other file types may contain malware.  These file types are usually a precursor or initial stage to eventually execute a malicious binary, but not always.  Other common file types that could be malicious include, but not limited to, ISOs, office files like Word and Excel, PDFs, and even EML.  Each file type may have its own techniques to safely analyze and interested readers should do more research on analysis methods for a given file type.
### Static Analysis
The safest method of analyzing suspicious software is through **static analysis** where the subject file is not executed but is analyzed using tools that avoid opening and running the file.  Any file can be handled and used, but when running the tool as its intended program, such as a PDF, the user runs the risk of infecting their system with the malware.  Analysts avoid this through the use of inspection tools that avoid running the program but can show elements of how the software might behave it is ran.

Most, but definitely not all, malware is a Windows portable executable (PE), or executable (EXE), file type that is ran when opened.  Such software is built using common dynamic link libraries (DLL), such as Kernel.dll, that imports useful functions like writing files, updating memory space, and making network connections, into the malware.  These DLLs and functions are typically written into a higher language like C++ and then compiled into a binary.  Opening a binary file using a text editor will display mostly non-human readable text as much of the binary consists of non-ASCII hexadecimal code meaningful to the operating system.  However, the binary will have many recognizable characters and often large sections or blocks of human readable characters.  The *strings* utility in Linux systems, and embedded as a feature in many Windows based analysis tools, dumps all consecutive ASCII representable bytes.  Many of these strings will include the names of functions from DLLs, and variables among other useful information, that are used as part of the malware.  These names and values could give a strong indication on the types of activities the malware might perform.  For example, the VirtualAllocEx function name could be identified using strings which indicates that the software may allocate new memory space in an open process - perhaps to use to store malicious code.

PEs include *sections* defined by headers that organize the compiled binary.  The `.text` section stores the assembled code of the program, `.data` has initialized data used by the program, `.idata` includes the imported symbols (names) of DLLs, the `.rdata` consists of read only initialized data, and finally the `.rsrc` sections contains resources used by the binary such as icons, menus, dialogs, version information, fonts, and others.   The data and resource sections of the malware may contain blocks of code that have been obfuscated, using a number of methods, to avoid detection by antivirus scanners.  This could mean that the data has been encrypted and will result in a block of data that has high entropy or randomness.  

>[!tip] Tip - Indicators
>Because malware shares so many features with benign software it can be challenging to rely on any single indicator to determine if a subject software is malicious.  Therefore, it is common to evaluate all indicators at the end of an assessment to determine if software may be malicious.

The resource section should also be evaluated closely for nonstandard resources and characteristics as well as its file type signature.  For instance, a resource could contain a zip file, PKZIP, that is obfuscated through compression.  Resources of interest could be extracted, unzipped, and then its contents evaluated further.  Malicious software might hide an executable within a zipped resource that is inflated and executed when the parent malware runs.  A great tool for analyzing portable executables using the methods described in the few previous paragraphs is PEStudio.  The following screenshot is from PEStudio analyzing the calc.exe application in Windows.

![[../images/11/pestudio.png|PEStudio Analysis of Calculator App|650]]

As the `.text` section stores the assembled code it is compelling to analyze further to understand how it might work.  The binary can be loaded into a *reverse engineering* tool, such as IDA or Ghidra, that *disassembles* the binary into assembly language.  Because assembly can be difficult to read, the disassembled code could also be *decompiled* into C where it could be relatively easier to read and comprehend the types of behavior the software possesses.  Decompilers won't generate code to its original state, as was when the code was written in an integrated development environment.  Much of the information used in the higher level program, such as names of variables and functions, will be lost as they do not persist in a compiled binary.  In their place are arbitrary names that don't give context to the code.  Therefore, reverse engineering decompiled code requires the analyst to rename functions and variables as they learn what they do.  From there, the analyst can gain a deeper understanding of what the program does and whether it is malicious.
### Dynamic Analysis
Another method of analysis is where the suspect file is executed and its activities are observed known as **dynamic analysis**.  This analysis is particularly useful when static analysis efforts do not conclusively determine if the software is safe.  For instance, if the data sections have high entropy it could be an indication that the data used in the program is encrypted which doesn't determine if the subject software is malicious.  Decrypting that data section may be too difficult to do statically, but the running software must decrypt it at some point during its execution in order to make use of the data.  Dynamic analysis is a short cut to this and similar problems.  But running suspicious software in a live environment will likely infect the machine so certain precautions have to be taken.  Setting up a dedicated testing machine that is safely partitioned away from the rest of the network and devices is called a *sandbox*.  This environment simulates a normal device and will have specialized tools designed to capture changes to the system, disk, and established network connections.

One such tool for Windows systems, called RegShot (https://github.com/Seabreg/Regshot), captures they file system and Registry state before and then after a file is executed.  The two snapshots of the system are then compared and reconciled to show what items have been updated, deleted, and added on the file system and Registry.  Prior to executing the malware in a sandbox environment, the analyst may setup other monitoring tools to capture network traffic, such as Wireshark.  Any connections to the internet or network would be captured for further analysis post execution of the malware.  Similarly, there are some techniques where an analyst will capture DNS queries and respond to network requests with placeholder information to *defang*, or mitigate impact, malware from downloading additional data or files.

Sysinternals toolset includes a tool called Process Monitor that operates much like the native Windows Task Manager, except it collects much more data on processes, registry changes, file changes, and network connections.  Unlike Task Manager, Process Monitor retains every request and includes a powerful filtering feature enabling an analysis to sort and find valuable insights on how the subject software is behaving.  Running subject software in a sandbox environment is a quick way to analyze a file's behavior when executed but it isn't the only way to dynamically analyze software.

![[../images/11/process_monitor.png|Running Process Monitor|600]]

Malware analysts can use software *debuggers*, such as x64dbg and Immunity, which attach to running software revealing the CPU registers and memory space (stack and heap) of the program.  Analysts can then walk through the execution of the program in granular steps assessing each assembly instruction at a time.  Other features include the ability to set break points and to patch, or modify, the program as it runs.  
### Anti-Analysis
In order to persist undiscovered for as long as possible, malware authors will design their malicious software to evade detection from automated systems like antivirus.  This can be as simple as encoding or encrypting malicious sections of the software.  Another common bypass is to make the file size larger then the maximum file size antivirus will scan - for Microsoft Defender it is 2 GB. [^3]  Malware can even hide itself in plain site by using seemingly common file and process names that could be quickly dismissed by someone investigating.  Malware can even hijack a legitimate running process by removing that process's code and data in memory and replacing it with malicious code, known as *process hollowing*.

However, at some point a security professional may be alerted to suspicious activity and collect the malware sample for analysis.  As covered in the previous section, they analyst will use a sandbox account and static and dynamic analysis tools.  Malware authors can anticipate their malware might be discovered and may attempt to hide the malware's activities, or otherwise slow down, analyst's investigations commonly referred to as **anti-analysis**.  One such method is to *pack* the binary which compresses its content into a reduced form making analysis more difficult.  It is similar to a JavaScript minifier if you are familiar with that technology.  Most popular packing software has an inflation algorithm that can be used to reverse the effects of packing; however, this could cause a stumbling block for a less experienced analyst.  The malware author could use other tactics to obfuscate the binary's features by encoding data sections or variables, inserting non-executable or junk code, and other code manipulation techniques.  [^4]

>[!tip] Tip - Malware Analysis Workstation
>Most security professionals will use a dedicated virtual machine on a dedicated host in a segmented network to perform malware analysis on.  This is to avoid incidental infections from spreading to other devices and networks.

Some malware is designed to detect if it is running in an analyst's lab by first checking if it has been ran in a virtual machine.  It will look for common virtualization drivers having been installed in the operating system, or it might cycle through names of files on the desktop looking for common malware analysis tools.  If the malware detects any of these patterns, it shuts down gracefully or runs a benign feature avoiding the execution of malicious code.  This will avoid several dynamic analysis techniques.  However, the analysis can overcome this obstacle by loading the software into a debugger and bypassing any such checks.

Even more sophisticated malware authors understand this and also implement checks to verify the running malware is not running in a debugger.  One of the first paths of execution will check Windows API usage of the `IsDebuggerPresent` flag or similar flags and functions.  If this flag is true then the malware shuts down causing the debugger to crash.


> [!activity] Activity 11.3 - Malware Analysis
> The WannaCry ransomware leveraged wormable SMB vulnerabilities to rapidly spread across the globe in 2016.  In this activity I will use online resources to statically and dynamically analyze WannaCry.  I will be in close proximity to this malware so it is best to use my Windows VM with the NAT network mode that allows access to the internet.  Take caution if you decide to download a sample as mishandling it may result in a ransomware infection.
> 
> After starting my Windows VM in bridge adapter network mode, I open Edge and navigate to Virus Total (https://www.virustotal.com/gui/home/search).  Within the search bar I enter the MD5 hash value of a sample file and run the search.
> ```
> 84c82835a5d21bbcf75a61706d8ab549
> ```
> ![[../images/11/analysis_activity_vt_search.png|Searching VirusTotal|600]]
> Upon hitting enter, VirusTotal looks up the hash value against a database of malware scans it has.  If the system has never analyzed the file it would return no results.  An option from there is to upload the file to VirusTotal where it runs a virus scan using 70+ popular anti-malware vendor tools before serving the summary results.  This result from the file would then be available to any anonymous user.  This hash I searched for has an alarming number of vendor reported malware hits who reference the name of this malware as WannaCry.
> ![[../images/11/analysis_activity_vt_hits.png|VirusTotal Summary Results|600]]
> The traditional virus scan tools used investigate against a known malicious hash database but we can also perform basic static analysis techniques using VirusTotal.  Navigating to the Details tab reveals several properties about the file such as the tools used to compiled the binary and when the program was created.  This file was compiled and packed using Visual C++ and is confirmed to be a Win32 EXE file type.
> ![[../images/11/analysis_activity_vt_basic.png|VirusTotal Basic Property Results|600]]
> We can also analyze the file's sections alongside their entropy ratings, which could indicate that the file has been packed or encrypted.  Entropy scores greater than 6, up to 8, may indicate an anti-analysis technique is being used to avoid detection.  The static analysis within VirusTotal also shows which Windows DLL imports are used along with any functions used within the binary.  Knowing what functions are commonly used in various types of malware helps the analyst determine if a binary could be malicious.  Executables that create files and processes may be benign, but these are also common activities malware also performs among many others. [^2]
> ![[../images/11/analysis_activity_vt_imports.png|VirusTotal Imports Details|600]]
> Another fantastic resource to investigate malware is the site Any.run.  This organization offers free dynamic sandbox malware analysis and shares results of any submitted file.  Like VirusTotal previous submissions can be searched for using the hash of a file or the user can submit a new file for analysis and availability to the community.  Next, I navigate to https://app.any.run/submissions and search `wannacry`.
> ![[../images/11/analysis_activity_any_search.png|Any.Run WannaCry Search|600]]
> Seems there are a few hundred hits on this search.  I opened the first 6 results and found one that matches the MD5 hash used in VirusTotal.  The results screen main pane displays screenshots from the activity performed when running the file.  With this sample the WannaCry encryption message is displayed indicating the malware infection.  Underneath the main pane is the network activity pane which lists the HTTP, DNS, and other network connections made while running the executable file.  This section includes an option to download the packet capture for further analysis.  The pane on the right of the screen includes summary information, along with the ability to export or download the sample, as well as the processes that started when running the file.  These processes show the activity performed by the malware such as file creation and memory changes.
> ![[../images/11/analysis_activity_any_result.png|Any.Run WannaCry Analysis Results|600]]
> While VirusTotal and Any.Run are powerful free online tools, proper investigations should be conducted on a malware analysis VM owned by the analyst and using tools similar to the ones that these online tools would use.  It is beyond the scope of this textbook to learn to use these tools in detail but interested readers are encouraged to learn more on this topic!

## Exercises
>[!exercise] Exercise 11.1 - Forensic Investigation
>In this task you will complete various tasks against an acquired USB image from EnCase software using Autopsy on your Windows VM in Bridge Adapter network mode.  You will likely need to increase the Windows VM CPU core count (4) and RAM size (6GB) for the software to run smoothly.  Make sure to revert these settings after the lab.
>#### Step 1 - Install Autopsy
>Within the Windows VM, open a browser and navigate to [https://www.autopsy.com/download/](https://www.autopsy.com/download/) and download the latest Windows 64-bit installer.  The browser may block the installer, make sure to "keep" the installer and then expand the Show More dropdown and "Keep anyway".
>
>Once downloaded, run the installer by double clicking the MSI file in your Downloads folder.  Make sure to run it once as nothing may happen for 30 seconds.  Windows SmartScreen may block the installer, make sure to expand the "More info" to display the "Run anyway" button.
>
>The Autopsy Setup wizard will start.  Follow the steps accepting the defaults and UAC prompts until the software is fully installed.  Make sure to Allow any Java installations when prompted.
>#### Step 2 - Case Setup
>With Autopsy installed, run the application from the Desktop shortcut and Create a New Case.  Name the case "USB Drop", set the Base Directory in a folder on your Desktop, and assign a case number.
>
>Save the forensics.E01 file to your Windows VM and Add Data Source as a "Disk Image or VM File".  Select the forensics.E01 as the Data Source path and select all Ingest Modules.  Once added wait a couple minutes for the analysis to complete by observing the status bar in the bottom right corner of Autopsy to complete.
>
>Once ingest modules have been fully analyzed, expand the Directory Tree's Data Sources hierarchy and confirm the drives folders are displayed (eg "American", "Pictures", and other folders).
>#### Step 3 - Analyze USB
>Analyze the data source by finding the following evidence using the search features (upper right corner) and the tree pane module results.  Make sure to provide a screenshot and description of HOW and WHERE you found the evidence.
>- 2 Email Addresses 
>- 2 URLs  
>- 2 Phone Numbers    
>- 1 Zip File 
>- 1 JPG Metadata 
>- 1 PDF Magic Byte Hex Code 
>- 1 File with an Extension Mismatch
>#### Step 4 - Carve Deleted File
>Find a deleted file (tree) and carve/export (right-click) the file locally to your forensics workstation.  Identify the file type, meta data, and its contents.

>[!exercise] Exercise 11.2 - Malware Detection
>Yara is a malware detection tool supported by a large opensource and commercial community. The tool enables an analyst to quickly create a ruleset that can be used to detect malicious software. In this task you will create a custom Yara rule to identify a malicious file using your Kali VM running in Bridge Adapter network mode.
>#### Step 1 - Install Yara
>In your Kali VM, launch a terminal, update your system, and install yara using apt.
>```bash
>sudo apt update -y
>sudo apt install yara -y
>```
>Verify yara installed by running the help menu and reviewing its capabilities.
>```bash
>yara --help
>```
>#### Step 2 - Analyze Known Malware
>We will analyze the local copy of mimikatz installed on your Kali VM. Mimikatz is a Windows credential dumping utility used to extract Windows passwords and is often integrated in other malware. The 64 bit executable is located at the following path on your Kali VM "/usr/share/windows-resources/mimikatz/x64/mimikatz.exe".
>
>Identify a string that can be used in our Yara rule. Run the "strings" tool on the file and pipe to the "less" utility to identify Windows API crypto functions. BCrypt API functions are used by Windows to perform cryptographic operations which are also used by Mimikatz to extract passwords/hashes. Type "/BCrypt" while in the less editor and press enter.   Press "q" to exit less when satisfied.
>```bash
>strings /usr/share/windows-resources/mimikatz/x64/mimikatz.exe | less
>/BCrypt
>```
>Next, identify some hexcode in the mimikatz.exe. Using hexeditor, identify a unique section of shellcode. While in the editor, go to offset 1382E0 by pressing "CTRL+T" and enter the offset value. This snippet of hexcode may be a good candidate to fingerprint mimikatz. Copy this hex line to use in our Yara. Press "CTRL+C" to exit the editor once finished.
>```bash
>hexeditor /usr/share/windows-resources/mimikatz/x64/mimikatz.exe
>```
>#### Step 3 - Create Custom Yara Rule
>Create a yara ruleset in a file called mimikatz.yar that uses the string and hex code identified in the previous step. Use the following template and your favorite text editor. The strings section informs the yara tool which strings and hexcode to find in a given file. The condition section qualifies which strings need to be present for the rule to trigger.  Make sure to replace HEX_CODE_HERE with the hexcode you found in hexeditor from the previous step.
>```bash
>nano mimikatz.yar
>```
>And enter the following code into mimikatz.yar.
>```yara
>rule mimikatz_x64_exe 
>{ 
>	strings: 
>		$hex = { HEX_CODE_HERE } 
>		$string = "BCrypt" nocase 
>	condition: 
>		all of them 
>} 
>```
> #### Step 4 - Find Malware Using Yara
> With the rule created, run yara on the "/usr/share/windows-resources" directory recursively to identify all files that contain the subject string and hexcode. Files listed indicate a match.
> ```bash
> sudo yara -r mimikatz.yar /usr/share/windows-resources
> ```

>[!exercise] Exercise 11.3 - Malware Analysis
>The WannaCry ransomware leveraged wormable SMB vulnerabilities to rapidly spread across the globe in 2016. In this lab you will use online resources to statically and dynamically analyze WannaCry. You will be in close proximity to this malware so it is best to use one of your VMs with the NAT network mode. Take caution if you decide to download a sample as mishandling it may result in a ransomware infection.
>#### Step 1 - Static Analysis
>Navigate to [https://www.virustotal.com/gui/home/search](https://www.virustotal.com/gui/home/search) , enter the MD5 hash "84c82835a5d21bbcf75a61706d8ab549", and observe most AV vendors identify the hash as WannaCry. 
>
>Select the Details tab and review the properties. Observe what tools compiled the program and when it was created.
>#### Step 2 - Dynamic Analysis
>Navigate to [https://app.any.run/submissions](https://app.any.run/submissions) and type "wannacry" in the search bar. Observe several submissions populate with the MD5 hash "84c82835a5d21bbcf75a61706d8ab549". 
>
>Select one of the submissions to review the already ran dynamic analysis results. Cycle through the screenshots to visually see how the malware behaved. Note, some submissions may only contain one; cycle through submissions until you find one that looks the most interesting. 
>
>Observe the malware's behavior on the right pane. You should be able to see the process trees created and the commands ran in the background. 
>
>Investigate the Network activities in the bottom pane. Discover what connections were made while the malware rand. 
>
>Review the Files activity in the bottom pane and determine what files were read and written to. Any file that ends in ".mnry" extension has been encrypted by the malware.
>#### Step 3 - Explore Any.Run
>Navigate to [https://app.any.run](https://app.any.run/) public submissions section and find a user submission that identifies malware. Perform your own Static and Dynamic analysis using VirusTotal and the already submitted sample in Any.Run. Describe the malware's properties and behavior in a short report.

[^1]: The history of malware: A primer on the evolution of cyber threats - IBM Blog; IBM; March 31, 2024; https://www.ibm.com/blog/malware-history/
[^2]: Common API used in Malware; HackTricks; April 6th, 2024; https://book.hacktricks.xyz/reversing/common-api-used-in-malware
[^3]: Malware scanning in Microsoft Defender for Storage - Microsoft Defender for Cloud; Microsoft; April 6th, 2024; https://learn.microsoft.com/en-us/azure/defender-for-cloud/defender-for-storage-malware-scan
[^4]: Most Common Malware Obfuscation Techniques - Security Investigation; SOC Investigation; April 6th, 2024; https://www.socinvestigation.com/most-common-malware-obfuscation-techniques/